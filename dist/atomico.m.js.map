{"version":3,"file":"atomico.m.js","sources":["../src/vdom.js","../src/constants.js","../src/utils.js","../src/diff.js","../src/element.js"],"sourcesContent":["/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n * @return {VDom}\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return new VDom(tag, props, concat(children));\r\n}\r\n/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n */\r\nexport function VDom(tag, props, children) {\r\n    this.tag = tag;\r\n    this.props = props || {};\r\n    this.children = children || [];\r\n}\r\n\r\nexport function isDom(tag) {\r\n    return tag !== null && typeof tag === \"object\" && tag.nodeType !== 11\r\n        ? true\r\n        : false;\r\n}\r\n/**\r\n *\r\n * @param {*} value\r\n * @return {Boolean}\r\n */\r\nexport function isVDom(value) {\r\n    return typeof value === \"object\" && value instanceof VDom;\r\n}\r\n/**\r\n * prepares the children associated with virtual dom, managing to simplify the algorithm of diff\r\n * @param {*} children - list of children associated with the virtual dom\r\n * @param {*} merge - array that concatenates all the children independent of the depth of the array\r\n * @return {Array}\r\n */\r\nexport function concat(children, merge = []) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        let child = children[i];\r\n        Array.isArray(child)\r\n            ? concat(child, merge)\r\n            : merge.push(\r\n                  isVDom(child)\r\n                      ? child\r\n                      : isDom(child)\r\n                          ? new VDom(child, {}, \"\")\r\n                          : new VDom(\"\", {}, child || \"\")\r\n              );\r\n    }\r\n    return merge;\r\n}\r\n","export const ELEMENT = \"__atomico_el__\";\r\nexport const MASTER = \"__atomico_prev__\";\r\n","export function camelCase(string) {\r\n    return string.replace(/-+([\\w])/g, (all, letter) => letter.toUpperCase());\r\n}\r\n\r\nexport function defer(handler) {\r\n    return Promise.resolve().then(handler);\r\n}\r\n\r\nexport function root(parent) {\r\n    return parent.shadowRoot || parent;\r\n}\r\nexport function remove(parent, child) {\r\n    root(parent).removeChild(child);\r\n}\r\n\r\nexport function append(parent, child) {\r\n    root(parent).appendChild(child);\r\n}\r\n\r\nexport function replace(parent, newChild, oldChild) {\r\n    root(parent).replaceChild(newChild, oldChild);\r\n}\r\n\r\nexport function getListeners(obj) {\r\n    let props = [];\r\n    do {\r\n        props = props.concat(Object.getOwnPropertyNames(obj));\r\n    } while ((obj = Object.getPrototypeOf(obj)));\r\n    return props.reduce((listeners, prop) => {\r\n        if (/on[A-Z]/.test(prop) && listeners.indexOf(prop) === -1) {\r\n            listeners.push({\r\n                type: prop.replace(/on([A-Z])/, (all, letter) =>\r\n                    letter.toLowerCase()\r\n                ),\r\n                method: prop\r\n            });\r\n        }\r\n        return listeners;\r\n    }, []);\r\n}\r\n","import { ELEMENT, MASTER } from \"./constants\";\r\n\r\nimport { remove, append, replace, root } from \"./utils\";\r\nimport { VDom, h, isDom } from \"./vdom\";\r\n/**\r\n * compares the attributes associated with the 2 render states\r\n * @param {HTMLELement} node\r\n * @param {Object} prev - properties that the node already has\r\n * @param {Object} next - object with the new properties to define the node\r\n * @param {Boolean} [svg] - define if the html element is a svg\r\n * @param {Object} [collect] -It allows to recover properties, avoiding in turn the analysis\r\n *                            of these on the node, these are returned in an object in association\r\n *                            with the key of the loop\r\n * @return {Object} Collected properties\r\n */\r\nexport function diffProps(node, prev, next, svg, collect) {\r\n    // generates a list of the existing attributes in both versions\r\n    let keys = Object.keys(prev).concat(Object.keys(next)),\r\n        props = {};\r\n\r\n    for (let i = 0; i < keys.length; i++) {\r\n        let prop = keys[i];\r\n        if (prev[prop] !== next[prop]) {\r\n            /**\r\n             * Since prop is defined, Atomico will proceed only to take the attributes\r\n             * defined for the component, the undefined ones continue the normal process\r\n             */\r\n            if (collect && collect.indexOf(prop) > -1) {\r\n                props[prop] = next[prop];\r\n                continue;\r\n            }\r\n            if (\r\n                typeof next[prop] === \"function\" ||\r\n                typeof prev[prop] === \"function\"\r\n            ) {\r\n                if (prev[prop]) node.removeEventListener(prop, prev[prop]);\r\n                node.addEventListener(prop, next[prop]);\r\n            } else if (prop in next) {\r\n                if ((prop in node && !svg) || (svg && prop === \"style\")) {\r\n                    if (prop === \"style\") {\r\n                        if (typeof next[prop] === \"object\") {\r\n                            for (let index in next[prop]) {\r\n                                node.style[index] = next[prop][index];\r\n                            }\r\n                        } else {\r\n                            node.style.cssText = next[prop];\r\n                        }\r\n                    } else {\r\n                        node[prop] = next[prop];\r\n                    }\r\n                } else {\r\n                    if (svg && prop === \"xmlns\") continue;\r\n                    svg\r\n                        ? node.setAttributeNS(null, prop, next[prop])\r\n                        : node.setAttribute(prop, next[prop]);\r\n                }\r\n            } else {\r\n                node.removeAttribute(prop);\r\n            }\r\n        }\r\n    }\r\n    return props;\r\n}\r\n/**\r\n *\r\n * @param {VDom} vdom - It allows to identify if this node requires the use of a slot\r\n * @param {Object} slots - Object that has living nodes associated by an index\r\n */\r\nfunction slot(vdom, slots) {\r\n    if (vdom.tag === \"slot\") {\r\n        return new VDom(\r\n            slots[vdom.props.name] || \"\",\r\n            vdom.props,\r\n            vdom.children\r\n        );\r\n    }\r\n    return vdom;\r\n}\r\n/**\r\n * Analyze if prev Node has or does not have a state defined by the diff process,\r\n * this is left linked to the node to avoid its loss either by external editing.\r\n *\r\n * @param {HTMLELement} [parent] - If the father is defined, the remove function is activated,\r\n *                                 it allows to remove the nodes from the father\r\n * @param {HTMLELement} [prevNode] - Node that can possess the previous state\r\n * @param {Object} next - Next render state\r\n * @param {Object} slots - Group the slots to be retrieved by the special slot tag\r\n * @param {Boolean} svg - define if the html element is a svg\r\n * @return {HTMLELement} - returns the current node.\r\n */\r\nexport function diff(parent, prevNode, next, slots = {}, svg) {\r\n    let prev = prevNode && prevNode[MASTER] ? prevNode[MASTER] : new VDom(),\r\n        nextNode = prevNode,\r\n        master = next,\r\n        dom;\r\n    if (next) {\r\n        next = slot(next, slots);\r\n        prev = slot(prev, slots);\r\n        svg = svg || next.tag === \"svg\";\r\n        dom = isDom(next.tag);\r\n        if (parent) {\r\n            if (prev.tag !== next.tag) {\r\n                if (dom) {\r\n                    nextNode = next.tag;\r\n                    prevNode\r\n                        ? replace(parent, nextNode, prevNode)\r\n                        : append(parent, nextNode);\r\n                } else if (next.tag) {\r\n                    nextNode = svg\r\n                        ? document.createElementNS(\r\n                              \"http://www.w3.org/2000/svg\",\r\n                              next.tag\r\n                          )\r\n                        : document.createElement(next.tag);\r\n                    if (prevNode) {\r\n                        replace(parent, nextNode, prevNode);\r\n                        if (!nextNode[ELEMENT]) {\r\n                            while (prevNode.firstChild) {\r\n                                append(nextNode, prevNode.firstChild);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        append(parent, nextNode);\r\n                    }\r\n                } else {\r\n                    nextNode = document.createTextNode(\"\");\r\n                    if (prev.tag) {\r\n                        replace(parent, nextNode, prevNode);\r\n                    } else {\r\n                        append(parent, nextNode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (nextNode.nodeType === 3) {\r\n            if (prev.children !== next.children)\r\n                nextNode.textContent = next.children;\r\n        } else {\r\n            let isElement = nextNode[Element],\r\n                props = diffProps(\r\n                    nextNode,\r\n                    prev.props,\r\n                    next.props,\r\n                    svg,\r\n                    isElement && nextNode._props.keys\r\n                );\r\n            if (isElement) {\r\n                props.children = next.children.map(\r\n                    vdom => (vdom.tag ? vdom : vdom.children)\r\n                );\r\n                this.setProperties(props);\r\n            } else {\r\n                if (nextNode) {\r\n                    let children = Array.from(nextNode.childNodes),\r\n                        length = Math.max(\r\n                            children.length,\r\n                            next.children.length\r\n                        );\r\n                    for (let i = 0; i < length; i++) {\r\n                        diff(\r\n                            nextNode,\r\n                            children[i],\r\n                            next.children[i],\r\n                            slots,\r\n                            svg\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        nextNode[MASTER] = master;\r\n    } else {\r\n        if (parent && prevNode) remove(parent, prevNode);\r\n    }\r\n    return parent;\r\n}\r\n","import { ELEMENT, MASTER } from \"./constants\";\r\nimport { h, isVDom } from \"./vdom\";\r\nimport { diff } from \"./diff\";\r\nimport { defer, camelCase, append } from \"./utils\";\r\n\r\nexport default class extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n\r\n        this[ELEMENT] = true;\r\n\r\n        this.slots = {};\r\n        this.props = {};\r\n        this.preventRender = true;\r\n        this.content = document.createDocumentFragment();\r\n\r\n        this.class = this.constructor;\r\n        this._props = {\r\n            keys: this.class.observedAttributes,\r\n            types: this.class.props\r\n        };\r\n    }\r\n    static get props() {\r\n        return {};\r\n    }\r\n    static get observedAttributes() {\r\n        return Object.keys(this.props).concat(\"children\");\r\n    }\r\n    get isMount() {\r\n        return this[MASTER];\r\n    }\r\n    connectedCallback() {\r\n        defer(() => {\r\n            let children = [];\r\n            while (this.firstChild) {\r\n                let child = this.firstChild,\r\n                    slot = child.getAttribute && child.getAttribute(\"slot\");\r\n                if (slot) {\r\n                    this.slots[slot] = child;\r\n                }\r\n                append(this.content, child);\r\n                children.push(child);\r\n            }\r\n            this.setProperties({ children });\r\n            this.preventRender = false;\r\n            this.setState({});\r\n        });\r\n    }\r\n    setAttribute(prop, value) {\r\n        if (this._props.keys.indexOf(prop) > -1) {\r\n            this.setProperties({ [prop]: value });\r\n        } else {\r\n            super.setAttribute(prop, value);\r\n        }\r\n    }\r\n    setProperties(props) {\r\n        let nextProps = {},\r\n            prevent = this.isMount;\r\n        for (let prop in props) {\r\n            let type = this._props.types[prop],\r\n                value = props[prop],\r\n                index;\r\n            if (type) {\r\n                value = type(value);\r\n            }\r\n            index = camelCase(prop);\r\n            if (value !== this.props[index]) {\r\n                nextProps[index] = value;\r\n            }\r\n        }\r\n        if (Object.keys(nextProps).length) {\r\n            if (prevent)\r\n                prevent = this.elementReceiveProps(nextProps) !== false;\r\n            this.props = { ...this.props, ...nextProps };\r\n            if (prevent) this.setState({});\r\n        }\r\n    }\r\n    attributeChangedCallback(index, prev, next) {\r\n        this.setProperties({ [index]: next });\r\n    }\r\n    disconnectedCallback() {\r\n        this.elementMount();\r\n    }\r\n    setState(state) {\r\n        if (typeof state !== \"object\") return;\r\n        this.state = { ...this.state, ...state };\r\n        if (this.preventRender) return;\r\n        this.preventRender = true;\r\n        defer(() => {\r\n            let render = this.render(),\r\n                isMount = this.isMount;\r\n            render =\r\n                isVDom(render) && render.tag === \"host\" ? (\r\n                    render\r\n                ) : (\r\n                    <host>{render}</host>\r\n                );\r\n\r\n            diff(false, this, render, this.slots);\r\n            this.preventRender = false;\r\n            isMount ? this.elementUpdate() : this.elementMount();\r\n        });\r\n    }\r\n    elementMount() {}\r\n    elementUnmount() {}\r\n    elementUpdate() {}\r\n    elementReceiveProps() {}\r\n    render() {}\r\n}\r\n"],"names":["h","tag","props","VDom","concat","children","this","isDom","nodeType","isVDom","value","merge","let","i","length","child","Array","isArray","push","const","ELEMENT","MASTER","camelCase","string","replace","all","letter","toUpperCase","defer","handler","Promise","resolve","then","root","parent","shadowRoot","remove","removeChild","append","appendChild","newChild","oldChild","replaceChild","diffProps","node","prev","next","svg","collect","keys","Object","prop","indexOf","removeEventListener","addEventListener","index","style","cssText","setAttributeNS","setAttribute","removeAttribute","slot","vdom","slots","name","diff","prevNode","dom","nextNode","master","document","createElementNS","createElement","firstChild","createTextNode","textContent","isElement","Element","_props","map","setProperties","from","childNodes","Math","max","HTMLElement","[object Object]","super","preventRender","content","createDocumentFragment","class","constructor","observedAttributes","types","isMount","getAttribute","setState","nextProps","prevent","type","elementReceiveProps","elementMount","state","render","elementUpdate"],"mappings":"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"}