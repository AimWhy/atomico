{"version":3,"file":"atomico.umd.js","sources":["../src/constants.js","../src/utils.js","../src/vdom.js","../src/diff.js","../src/element.js"],"sourcesContent":["export const ELEMENT = \"Atomico\";\r\n\r\nexport const MOUNT = \"elementMount\";\r\n\r\nexport const UNMOUNT = \"elementUnmount\";\r\n\r\nexport const UPDATE = \"elementUpdate\";\r\n\r\nexport const RECEIVE_PROPS = \"elementReceiveProps\";\r\n","export function camelCase(string) {\r\n    return string.replace(/-+([\\w])/g, (all, letter) => letter.toUpperCase());\r\n}\r\n\r\nexport function defer(handler) {\r\n    return requestAnimationFrame(handler);\r\n}\r\n\r\nexport function root(parent) {\r\n    return parent.shadowRoot || parent;\r\n}\r\nexport function remove(parent, child) {\r\n    root(parent).removeChild(child);\r\n}\r\n\r\nexport function append(parent, child) {\r\n    root(parent).appendChild(child);\r\n}\r\n\r\nexport function replace(parent, newChild, oldChild) {\r\n    root(parent).replaceChild(newChild, oldChild);\r\n}\r\n","/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n * @return {VDom}\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return new VDom(tag, props, concat(children));\r\n}\r\n/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n */\r\nexport function VDom(tag, props, children) {\r\n    this.tag = tag;\r\n    this.props = props || {};\r\n    this.children = children || [];\r\n}\r\n\r\nexport function isDom(tag) {\r\n    return tag !== null && typeof tag === \"object\" && tag.nodeType !== 11\r\n        ? true\r\n        : false;\r\n}\r\n/**\r\n *\r\n * @param {*} value\r\n * @return {Boolean}\r\n */\r\nexport function isVDom(value) {\r\n    return typeof value === \"object\" && value instanceof VDom;\r\n}\r\n/**\r\n * prepares the children associated with virtual dom, managing to simplify the algorithm of diff\r\n * @param {*} children - list of children associated with the virtual dom\r\n * @param {*} merge - array that concatenates all the children independent of the depth of the array\r\n * @return {Array}\r\n */\r\nexport function concat(children, merge = []) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        let child = children[i];\r\n        Array.isArray(child)\r\n            ? concat(child, merge)\r\n            : merge.push(\r\n                  isVDom(child)\r\n                      ? child\r\n                      : isDom(child)\r\n                          ? new VDom(child, {}, \"\")\r\n                          : new VDom(\"\", {}, child || \"\")\r\n              );\r\n    }\r\n    return merge;\r\n}\r\n","import { RECEIVE_PROPS, ELEMENT } from \"./constants\";\r\n\r\nimport { remove, append, replace, root } from \"./utils\";\r\nimport { VDom, h, isDom } from \"./vdom\";\r\n/**\r\n * compares the attributes associated with the 2 render states\r\n * @param {HTMLELement} node\r\n * @param {Object} prev - properties that the node already has\r\n * @param {Object} next - object with the new properties to define the node\r\n * @param {Boolean} [svg] - define if the html element is a svg\r\n * @param {Object} [props] - allows to define if the instance belongs to a component, if so it\r\n *                         will rescue the properties associated to the method `static get props`\r\n *                         through this variable, manages to transfer mutations and new children\r\n *                         associated with it to the component.\r\n */\r\nexport function diffProps(node, prev, next, svg, props) {\r\n    // generates a list of the existing attributes in both versions\r\n    let keys = Object.keys(prev).concat(Object.keys(next));\r\n\r\n    for (let i = 0; i < keys.length; i++) {\r\n        let prop = keys[i];\r\n        if (prev[prop] !== next[prop]) {\r\n            /**\r\n             * Since prop is defined, Atomico will proceed only to take the attributes\r\n             * defined for the component, the undefined ones continue the normal process\r\n             */\r\n            if (props && node._props.indexOf(prop) > -1) {\r\n                props[prop] = next[prop];\r\n                continue;\r\n            }\r\n            if (\r\n                typeof next[prop] === \"function\" ||\r\n                typeof prev[prop] === \"function\"\r\n            ) {\r\n                if (prev[prop]) node.removeEventListener(prop, prev[prop]);\r\n                node.addEventListener(prop, next[prop]);\r\n            } else if (prop in next) {\r\n                if ((prop in node && !svg) || (svg && prop === \"style\")) {\r\n                    if (prop === \"style\") {\r\n                        if (typeof next[prop] === \"object\") {\r\n                            for (let index in next[prop]) {\r\n                                node.style[index] = next[prop][index];\r\n                            }\r\n                        } else {\r\n                            node.style.cssText = next[prop];\r\n                        }\r\n                    } else {\r\n                        node[prop] = next[prop];\r\n                    }\r\n                } else {\r\n                    if (svg && prop === \"xmlns\") continue;\r\n                    svg\r\n                        ? node.setAttributeNS(null, prop, next[prop])\r\n                        : node.setAttribute(prop, next[prop]);\r\n                }\r\n            } else {\r\n                node.removeAttribute(prop);\r\n            }\r\n        }\r\n    }\r\n    if (props) node.setProps(props);\r\n}\r\n\r\nfunction slot(vdom, root) {\r\n    if (vdom.tag === \"slot\") {\r\n        vdom.tag = root.slots[vdom.props.name] || \"\";\r\n    }\r\n    return vdom;\r\n}\r\n/**\r\n * It allows to compare the 2 states of the render\r\n * @param {HTMLELement} node - will receive the changes that the diff process determines\r\n * @param {Array} master - Previous state of the render\r\n * @param {Array} commit - Next render state\r\n * @param {Boolean} svg - define if the html element is a svg\r\n */\r\nexport function diff(node, master, commit, root = node, svg) {\r\n    let children = node.childNodes || [],\r\n        length = Math.max(master.length, commit.length);\r\n    for (let i = 0; i < length; i++) {\r\n        let prev = master[i] || new VDom(),\r\n            next = commit[i],\r\n            child = children[i];\r\n\r\n        if (next) {\r\n            next = slot(next, root);\r\n            prev = slot(prev, root);\r\n\r\n            let cursor = child,\r\n                // Allows the use of real nodes\r\n                dom = isDom(next.tag);\r\n            svg = svg || next.tag === \"svg\";\r\n            if (prev.tag !== next.tag) {\r\n                if (dom) {\r\n                    cursor = next.tag;\r\n                    child ? replace(node, cursor, child) : append(node, cursor);\r\n                } else if (next.tag) {\r\n                    cursor = svg\r\n                        ? document.createElementNS(\r\n                              \"http://www.w3.org/2000/svg\",\r\n                              next.tag\r\n                          )\r\n                        : document.createElement(next.tag);\r\n                    if (child) {\r\n                        replace(node, cursor, child);\r\n                        // Avoid the merge if the child is a component\r\n                        if (!cursor[ELEMENT]) {\r\n                            while (child.firstChild) {\r\n                                append(cursor, child.firstChild);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        append(node, cursor);\r\n                    }\r\n                } else {\r\n                    cursor = document.createTextNode(\"\");\r\n                    if (prev.tag) {\r\n                        replace(node, cursor, child);\r\n                    } else {\r\n                        append(node, cursor);\r\n                    }\r\n                }\r\n            }\r\n            if (!dom && cursor.nodeName === \"#text\") {\r\n                if (prev.children !== next.children)\r\n                    cursor.textContent = next.children;\r\n            } else {\r\n                diffProps(\r\n                    cursor,\r\n                    prev.props,\r\n                    next.props,\r\n                    svg,\r\n                    // of being an Atomico component, the object is created to transmit the mutations\r\n                    cursor[ELEMENT] && {\r\n                        children: next.children.map(\r\n                            vdom => (vdom.tag ? vdom : vdom.children)\r\n                        )\r\n                    }\r\n                );\r\n                if (!dom && cursor && !cursor[ELEMENT]) {\r\n                    diff(cursor, prev.children, next.children, root, svg);\r\n                }\r\n            }\r\n        } else {\r\n            if (child) remove(node, child);\r\n        }\r\n    }\r\n}\r\n","import { MOUNT, UNMOUNT, RECEIVE_PROPS, UPDATE, ELEMENT } from \"./constants\";\r\n\r\nimport { diff } from \"./diff\";\r\nimport { concat } from \"./vdom\";\r\nimport { camelCase, root, append, defer } from \"./utils\";\r\n\r\nexport default class extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n        this[ELEMENT] = true;\r\n        this.state = {};\r\n        this.slots = {};\r\n        this.props = {};\r\n        this.fragment = document.createDocumentFragment();\r\n        this._props = this.constructor.props || [];\r\n        this._render = [];\r\n        this._listener = [];\r\n        this._mount;\r\n        this._prevent;\r\n        this.livecycle();\r\n    }\r\n    static get observedAttributes() {\r\n        return [\"children\"].concat(this.props || []);\r\n    }\r\n    livecycle() {\r\n        this.addEventListener(\r\n            MOUNT,\r\n            event => this[MOUNT] && this[MOUNT](event)\r\n        );\r\n        this.addEventListener(\r\n            UNMOUNT,\r\n            event => this[UNMOUNT] && this[UNMOUNT](event)\r\n        );\r\n        this.addEventListener(\r\n            UPDATE,\r\n            event => this[UPDATE] && this[UPDATE](event)\r\n        );\r\n        this.addEventListener(RECEIVE_PROPS, event => {\r\n            this[RECEIVE_PROPS] && this[RECEIVE_PROPS](event);\r\n            if (event.defaultPrevented) return;\r\n            this.setState({});\r\n        });\r\n    }\r\n    setAttribute(prop, value) {\r\n        if (this._props.indexOf(prop) > -1) {\r\n            this.setProps({ ...this.props, [prop]: value });\r\n        } else {\r\n            super.setAttribute(prop, value);\r\n        }\r\n    }\r\n    /**\r\n     * By default the children and properties are extracted\r\n     * only when the component exists in the document\r\n     * This is required for the component to be read regardless\r\n     * of the load instance, in the same way it is applied asynchronously,\r\n     * so as to be able to read the arguments generated by synchronous invocation,\r\n     * be it the use of document.createElement\r\n     */\r\n    connectedCallback() {\r\n        this.props.children = [];\r\n        defer(() => {\r\n            while (this.firstChild) {\r\n                let child = this.firstChild,\r\n                    slot = child.getAttribute && child.getAttribute(\"slot\");\r\n                if (slot) {\r\n                    this.slots[slot] = child;\r\n                }\r\n                append(this.fragment, child);\r\n                this.props.children.push(child);\r\n            }\r\n            this.setState({}, (this._mount = true));\r\n            this.dispatch(MOUNT);\r\n        });\r\n    }\r\n    disconnectedCallback() {\r\n        this.dispatch(UNMOUNT);\r\n        this._listener.forEach(handler => handler());\r\n    }\r\n    setProps(props) {\r\n        let nextProps = {};\r\n        for (let prop in props) {\r\n            if (this._props.indexOf(prop) === -1) continue;\r\n            nextProps[camelCase(prop)] = props[prop];\r\n        }\r\n        if (this._mount) this.dispatch(RECEIVE_PROPS, nextProps);\r\n        this.props = nextProps;\r\n    }\r\n    attributeChangedCallback(index, prev, next) {\r\n        this.setProps({ ...this.props, [index]: next });\r\n    }\r\n    addEventListener(type, handler, useCapture) {\r\n        super.addEventListener(type, handler, useCapture);\r\n        this._listener.push(() => this.removeEventListener(type, handler));\r\n    }\r\n    dispatch(type, detail) {\r\n        this.dispatchEvent(\r\n            new CustomEvent(type, {\r\n                cancelable: true,\r\n                detail\r\n            })\r\n        );\r\n    }\r\n    setState(next, ignoreUpdate) {\r\n        if (!next) return;\r\n        this.state = { ...this.state, ...next };\r\n        if (this._prevent) return;\r\n        this._prevent = true;\r\n        defer(() => {\r\n            let render = concat([this.render()]);\r\n            diff(root(this), this._render, render);\r\n            this._render = render;\r\n            this._prevent = false;\r\n            if (!ignoreUpdate) this.dispatch(UPDATE);\r\n        });\r\n    }\r\n    render() {}\r\n}\r\n"],"names":["const","ELEMENT","MOUNT","UNMOUNT","UPDATE","RECEIVE_PROPS","defer","handler","requestAnimationFrame","root","parent","shadowRoot","remove","child","removeChild","append","appendChild","replace","newChild","oldChild","replaceChild","VDom","tag","props","children","this","isDom","nodeType","concat","merge","let","i","length","Array","isArray","push","value","diffProps","node","prev","next","svg","keys","Object","prop","_props","indexOf","removeEventListener","addEventListener","index","style","cssText","setAttributeNS","setAttribute","removeAttribute","setProps","slot","vdom","slots","name","HTMLElement","[object Object]","super","state","fragment","document","createDocumentFragment","constructor","_render","_listener","_mount","_prevent","livecycle","observedAttributes","event","defaultPrevented","setState","firstChild","getAttribute","dispatch","forEach","string","nextProps","all","letter","toUpperCase","type","useCapture","detail","dispatchEvent","CustomEvent","cancelable","ignoreUpdate","render","diff","master","commit","childNodes","Math","max","cursor","dom","createElementNS","createElement","createTextNode","nodeName","map","textContent"],"mappings":"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"}