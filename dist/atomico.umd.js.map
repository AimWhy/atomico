{"version":3,"file":"atomico.umd.js","sources":["../src/vdom.js","../src/constants.js","../src/utils.js","../src/diff.js","../src/element.js"],"sourcesContent":["/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n * @return {VDom}\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return new VDom(tag, props, concat(children));\r\n}\r\n/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n */\r\nexport function VDom(tag, props, children) {\r\n    this.tag = tag;\r\n    this.props = props || {};\r\n    this.children = children || [];\r\n}\r\n\r\nexport function isDom(tag) {\r\n    return tag !== null && typeof tag === \"object\" && tag.nodeType !== 11\r\n        ? true\r\n        : false;\r\n}\r\n/**\r\n *\r\n * @param {*} value\r\n * @return {Boolean}\r\n */\r\nexport function isVDom(value) {\r\n    return typeof value === \"object\" && value instanceof VDom;\r\n}\r\n/**\r\n * prepares the children associated with virtual dom, managing to simplify the algorithm of diff\r\n * @param {*} children - list of children associated with the virtual dom\r\n * @param {*} merge - array that concatenates all the children independent of the depth of the array\r\n * @return {Array}\r\n */\r\nexport function concat(children, merge = []) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        let child = children[i];\r\n        Array.isArray(child)\r\n            ? concat(child, merge)\r\n            : merge.push(\r\n                  isVDom(child)\r\n                      ? child\r\n                      : isDom(child)\r\n                          ? new VDom(child, {}, \"\")\r\n                          : new VDom(\"\", {}, child || \"\")\r\n              );\r\n    }\r\n    return merge;\r\n}\r\n","export const ELEMENT = \"__atomico_el__\";\r\nexport const MASTER = \"__atomico_prev__\";\r\n","export function camelCase(string) {\r\n    return string.replace(/-+([\\w])/g, (all, letter) => letter.toUpperCase());\r\n}\r\n\r\nexport function defer(handler) {\r\n    return Promise.resolve().then(handler);\r\n}\r\n\r\nexport function root(parent) {\r\n    return parent.shadowRoot || parent;\r\n}\r\nexport function remove(parent, child) {\r\n    root(parent).removeChild(child);\r\n}\r\n\r\nexport function append(parent, child) {\r\n    root(parent).appendChild(child);\r\n}\r\n\r\nexport function replace(parent, newChild, oldChild) {\r\n    root(parent).replaceChild(newChild, oldChild);\r\n}\r\n\r\nexport function getListeners(obj) {\r\n    let props = [];\r\n    do {\r\n        props = props.concat(Object.getOwnPropertyNames(obj));\r\n    } while ((obj = Object.getPrototypeOf(obj)));\r\n    return props.reduce((listeners, prop) => {\r\n        if (/on[A-Z]/.test(prop) && listeners.indexOf(prop) === -1) {\r\n            listeners.push({\r\n                type: prop.replace(/on([A-Z])/, (all, letter) =>\r\n                    letter.toLowerCase()\r\n                ),\r\n                method: prop\r\n            });\r\n        }\r\n        return listeners;\r\n    }, []);\r\n}\r\n","import { ELEMENT, MASTER } from \"./constants\";\r\n\r\nimport { remove, append, replace, root } from \"./utils\";\r\nimport { VDom, h, isDom } from \"./vdom\";\r\n/**\r\n * compares the attributes associated with the 2 render states\r\n * @param {HTMLELement} node\r\n * @param {Object} prev - properties that the node already has\r\n * @param {Object} next - object with the new properties to define the node\r\n * @param {Boolean} [svg] - define if the html element is a svg\r\n * @param {Object} [collect] -It allows to recover properties, avoiding in turn the analysis\r\n *                            of these on the node, these are returned in an object in association\r\n *                            with the key of the loop\r\n * @return {Object} Collected properties\r\n */\r\nexport function diffProps(node, prev, next, svg, collect) {\r\n    // generates a list of the existing attributes in both versions\r\n    let keys = Object.keys(prev).concat(Object.keys(next)),\r\n        props = {};\r\n\r\n    for (let i = 0; i < keys.length; i++) {\r\n        let prop = keys[i];\r\n        if (prev[prop] !== next[prop]) {\r\n            /**\r\n             * Since prop is defined, Atomico will proceed only to take the attributes\r\n             * defined for the component, the undefined ones continue the normal process\r\n             */\r\n            if (collect && collect.indexOf(prop) > -1) {\r\n                props[prop] = next[prop];\r\n                continue;\r\n            }\r\n            if (\r\n                typeof next[prop] === \"function\" ||\r\n                typeof prev[prop] === \"function\"\r\n            ) {\r\n                if (prev[prop]) node.removeEventListener(prop, prev[prop]);\r\n                node.addEventListener(prop, next[prop]);\r\n            } else if (prop in next) {\r\n                if ((prop in node && !svg) || (svg && prop === \"style\")) {\r\n                    if (prop === \"style\") {\r\n                        if (typeof next[prop] === \"object\") {\r\n                            for (let index in next[prop]) {\r\n                                node.style[index] = next[prop][index];\r\n                            }\r\n                        } else {\r\n                            node.style.cssText = next[prop];\r\n                        }\r\n                    } else {\r\n                        node[prop] = next[prop];\r\n                    }\r\n                } else {\r\n                    if (svg && prop === \"xmlns\") continue;\r\n                    svg\r\n                        ? node.setAttributeNS(null, prop, next[prop])\r\n                        : node.setAttribute(prop, next[prop]);\r\n                }\r\n            } else {\r\n                node.removeAttribute(prop);\r\n            }\r\n        }\r\n    }\r\n    return props;\r\n}\r\n/**\r\n *\r\n * @param {VDom} vdom - It allows to identify if this node requires the use of a slot\r\n * @param {Object} slots - Object that has living nodes associated by an index\r\n */\r\nfunction slot(vdom, slots) {\r\n    if (vdom.tag === \"slot\") {\r\n        return new VDom(\r\n            slots[vdom.props.name] || \"\",\r\n            vdom.props,\r\n            vdom.children\r\n        );\r\n    }\r\n    return vdom;\r\n}\r\n/**\r\n * Analyze if prev Node has or does not have a state defined by the diff process,\r\n * this is left linked to the node to avoid its loss either by external editing.\r\n *\r\n * @param {HTMLELement} [parent] - If the father is defined, the remove function is activated,\r\n *                                 it allows to remove the nodes from the father\r\n * @param {HTMLELement} [prevNode] - Node that can possess the previous state\r\n * @param {Object} next - Next render state\r\n * @param {Object} slots - Group the slots to be retrieved by the special slot tag\r\n * @param {Boolean} svg - define if the html element is a svg\r\n * @return {HTMLELement} - returns the current node.\r\n */\r\nexport function diff(parent, prevNode, next, slots = {}, svg) {\r\n    let prev = prevNode && prevNode[MASTER] ? prevNode[MASTER] : new VDom(),\r\n        nextNode = prevNode,\r\n        master = next,\r\n        dom;\r\n    if (next) {\r\n        next = slot(next, slots);\r\n        prev = slot(prev, slots);\r\n        svg = svg || next.tag === \"svg\";\r\n        dom = isDom(next.tag);\r\n        if (parent) {\r\n            if (prev.tag !== next.tag) {\r\n                if (dom) {\r\n                    nextNode = next.tag;\r\n                    prevNode\r\n                        ? replace(parent, nextNode, prevNode)\r\n                        : append(parent, nextNode);\r\n                } else if (next.tag) {\r\n                    nextNode = svg\r\n                        ? document.createElementNS(\r\n                              \"http://www.w3.org/2000/svg\",\r\n                              next.tag\r\n                          )\r\n                        : document.createElement(next.tag);\r\n                    if (prevNode) {\r\n                        replace(parent, nextNode, prevNode);\r\n                        if (!nextNode[ELEMENT]) {\r\n                            while (prevNode.firstChild) {\r\n                                append(nextNode, prevNode.firstChild);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        append(parent, nextNode);\r\n                    }\r\n                } else {\r\n                    nextNode = document.createTextNode(\"\");\r\n                    if (prev.tag) {\r\n                        replace(parent, nextNode, prevNode);\r\n                    } else {\r\n                        append(parent, nextNode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (nextNode.nodeType === 3) {\r\n            if (prev.children !== next.children)\r\n                nextNode.textContent = next.children;\r\n        } else {\r\n            let isElement = nextNode[Element],\r\n                props = diffProps(\r\n                    nextNode,\r\n                    prev.props,\r\n                    next.props,\r\n                    svg,\r\n                    isElement && nextNode._props.keys\r\n                );\r\n            if (isElement) {\r\n                props.children = next.children.map(\r\n                    vdom => (vdom.tag ? vdom : vdom.children)\r\n                );\r\n                this.setProperties(props);\r\n            } else {\r\n                if (nextNode) {\r\n                    let children = Array.from(nextNode.childNodes),\r\n                        length = Math.max(\r\n                            children.length,\r\n                            next.children.length\r\n                        );\r\n                    for (let i = 0; i < length; i++) {\r\n                        diff(\r\n                            nextNode,\r\n                            children[i],\r\n                            next.children[i],\r\n                            slots,\r\n                            svg\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        nextNode[MASTER] = master;\r\n    } else {\r\n        if (parent && prevNode) remove(parent, prevNode);\r\n    }\r\n    return parent;\r\n}\r\n","import { ELEMENT, MASTER } from \"./constants\";\r\nimport { h, isVDom } from \"./vdom\";\r\nimport { diff } from \"./diff\";\r\nimport { defer, camelCase, append } from \"./utils\";\r\n\r\nexport default class extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n\r\n        this[ELEMENT] = true;\r\n\r\n        this.slots = {};\r\n        this.props = {};\r\n        this.preventRender = true;\r\n        this.content = document.createDocumentFragment();\r\n\r\n        this.class = this.constructor;\r\n        this._props = {\r\n            keys: this.class.observedAttributes,\r\n            types: this.class.props\r\n        };\r\n    }\r\n    static get props() {\r\n        return {};\r\n    }\r\n    static get observedAttributes() {\r\n        return Object.keys(this.props).concat(\"children\");\r\n    }\r\n    get isMount() {\r\n        return this[MASTER];\r\n    }\r\n    connectedCallback() {\r\n        defer(() => {\r\n            let children = [];\r\n            while (this.firstChild) {\r\n                let child = this.firstChild,\r\n                    slot = child.getAttribute && child.getAttribute(\"slot\");\r\n                if (slot) {\r\n                    this.slots[slot] = child;\r\n                }\r\n                append(this.content, child);\r\n                children.push(child);\r\n            }\r\n            this.setProperties({ children });\r\n            this.preventRender = false;\r\n            this.setState({});\r\n        });\r\n    }\r\n    setAttribute(prop, value) {\r\n        if (this._props.keys.indexOf(prop) > -1) {\r\n            this.setProperties({ [prop]: value });\r\n        } else {\r\n            super.setAttribute(prop, value);\r\n        }\r\n    }\r\n    setProperties(props) {\r\n        let nextProps = {},\r\n            prevent = this.isMount;\r\n        for (let prop in props) {\r\n            let type = this._props.types[prop],\r\n                value = props[prop],\r\n                index;\r\n            if (type) {\r\n                value = type(value);\r\n            }\r\n            index = camelCase(prop);\r\n            if (value !== this.props[index]) {\r\n                nextProps[index] = value;\r\n            }\r\n        }\r\n        if (Object.keys(nextProps).length) {\r\n            if (prevent)\r\n                prevent = this.elementReceiveProps(nextProps) !== false;\r\n            this.props = { ...this.props, ...nextProps };\r\n            if (prevent) this.setState({});\r\n        }\r\n    }\r\n    attributeChangedCallback(index, prev, next) {\r\n        this.setProperties({ [index]: next });\r\n    }\r\n    disconnectedCallback() {\r\n        this.elementMount();\r\n    }\r\n    setState(state) {\r\n        if (typeof state !== \"object\") return;\r\n        this.state = { ...this.state, ...state };\r\n        if (this.preventRender) return;\r\n        this.preventRender = true;\r\n        defer(() => {\r\n            let render = this.render(),\r\n                isMount = this.isMount;\r\n            render =\r\n                isVDom(render) && render.tag === \"host\" ? (\r\n                    render\r\n                ) : (\r\n                    <host>{render}</host>\r\n                );\r\n\r\n            diff(false, this, render, this.slots);\r\n            this.preventRender = false;\r\n            isMount ? this.elementUpdate() : this.elementMount();\r\n        });\r\n    }\r\n    elementMount() {}\r\n    elementUnmount() {}\r\n    elementUpdate() {}\r\n    elementReceiveProps() {}\r\n    render() {}\r\n}\r\n"],"names":["h","tag","props","VDom","concat","children","merge","let","i","length","child","Array","isArray","push","isVDom","isDom","this","nodeType","value","const","ELEMENT","MASTER","defer","handler","Promise","resolve","then","root","parent","shadowRoot","append","appendChild","replace","newChild","oldChild","replaceChild","slot","vdom","slots","name","diff","prevNode","next","svg","dom","prev","nextNode","master","document","createElementNS","createElement","firstChild","createTextNode","textContent","isElement","Element","node","collect","keys","Object","prop","indexOf","removeEventListener","addEventListener","index","style","cssText","setAttributeNS","setAttribute","removeAttribute","diffProps","_props","map","setProperties","from","childNodes","Math","max","removeChild","remove","HTMLElement","[object Object]","super","preventRender","content","createDocumentFragment","class","constructor","observedAttributes","types","isMount","getAttribute","setState","nextProps","prevent","type","all","letter","toUpperCase","elementReceiveProps","elementMount","state","render","elementUpdate"],"mappings":"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"}