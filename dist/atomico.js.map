{"version":3,"file":"atomico.js","sources":["../src/vdom.js","../src/constants.js","../src/utils.js","../src/diff.js","../src/element.js"],"sourcesContent":["/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n * @return {VDom}\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return new VDom(tag, props, concat(children));\r\n}\r\n/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n */\r\nexport function VDom(tag, props, children) {\r\n    this.tag = tag;\r\n    this.props = props || {};\r\n    this.children = children || [];\r\n}\r\n\r\nexport function isDom(tag) {\r\n    return tag !== null && typeof tag === \"object\" && tag.nodeType !== 11\r\n        ? true\r\n        : false;\r\n}\r\n/**\r\n *\r\n * @param {*} value\r\n * @return {Boolean}\r\n */\r\nexport function isVDom(value) {\r\n    return typeof value === \"object\" && value instanceof VDom;\r\n}\r\n/**\r\n * prepares the children associated with virtual dom, managing to simplify the algorithm of diff\r\n * @param {*} children - list of children associated with the virtual dom\r\n * @param {*} merge - array that concatenates all the children independent of the depth of the array\r\n * @return {Array}\r\n */\r\nexport function concat(children, merge = []) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        let child = children[i];\r\n        Array.isArray(child)\r\n            ? concat(child, merge)\r\n            : merge.push(\r\n                  isVDom(child)\r\n                      ? child\r\n                      : isDom(child)\r\n                          ? new VDom(child, {}, [\"\"])\r\n                          : new VDom(\"\", {}, [child || \"\"])\r\n              );\r\n    }\r\n    return merge;\r\n}\r\n","export const ELEMENT = \"__atomico_el__\";\r\nexport const MASTER = \"__atomico_prev__\";\r\n","export function camelCase(string) {\r\n    return string.replace(/-+([\\w])/g, (all, letter) => letter.toUpperCase());\r\n}\r\n\r\nexport function defer(handler) {\r\n    return Promise.resolve().then(handler);\r\n}\r\n\r\nexport function root(parent) {\r\n    return parent.shadowRoot || parent;\r\n}\r\nexport function remove(parent, child) {\r\n    root(parent).removeChild(child);\r\n}\r\n\r\nexport function append(parent, child) {\r\n    root(parent).appendChild(child);\r\n}\r\n\r\nexport function replace(parent, newChild, oldChild) {\r\n    root(parent).replaceChild(newChild, oldChild);\r\n}\r\n\r\nexport function getProps(props) {\r\n    let isArray = Array.isArray(props);\r\n    return {\r\n        keys: (isArray ? props : Object.keys(props)).concat(\"children\"),\r\n        types: isArray ? {} : props\r\n    };\r\n}\r\n","import { ELEMENT, MASTER } from \"./constants\";\r\n\r\nimport { remove, append, replace, root } from \"./utils\";\r\nimport { VDom, h, isDom } from \"./vdom\";\r\n/**\r\n * compares the attributes associated with the 2 render states\r\n * @param {HTMLELement} node\r\n * @param {Object} prev - properties that the node already has\r\n * @param {Object} next - object with the new properties to define the node\r\n * @param {Boolean} [svg] - define if the html element is a svg\r\n * @param {Object} [collect] -It allows to recover properties, avoiding in turn the analysis\r\n *                            of these on the node, these are returned in an object in association\r\n *                            with the key of the loop\r\n * @param {Boolean} [nextMerge] - it allows not to eliminate the properties of the previous state and add them to the next state\r\n * @return {Object} Collected properties\r\n */\r\nexport function diffProps(node, prev, next, svg, collect, nextMerge) {\r\n    // generates a list of the existing attributes in both versions\r\n    let keys = Object.keys(prev).concat(Object.keys(next)),\r\n        length = keys.length,\r\n        props = {};\r\n\r\n    for (let i = 0; i < length; i++) {\r\n        let prop = keys[i];\r\n        if (prev[prop] !== next[prop]) {\r\n            /**\r\n             * Since prop is defined, Atomico will proceed only to take the attributes\r\n             * defined for the component, the undefined ones continue the normal process\r\n             */\r\n            if (collect && collect.indexOf(prop) > -1) {\r\n                props[prop] = next[prop];\r\n                continue;\r\n            }\r\n            if (\r\n                typeof next[prop] === \"function\" ||\r\n                typeof prev[prop] === \"function\"\r\n            ) {\r\n                if (prev[prop]) node.removeEventListener(prop, prev[prop]);\r\n                node.addEventListener(prop, next[prop]);\r\n            } else if (prop in next) {\r\n                if ((prop in node && !svg) || (svg && prop === \"style\")) {\r\n                    if (prop === \"style\") {\r\n                        if (typeof next[prop] === \"object\") {\r\n                            let prevStyle = prev[prop] || {},\r\n                                nextStyle = next[prop];\r\n                            for (let index in nextStyle) {\r\n                                if (prevStyle[index] !== nextStyle[index]) {\r\n                                    node.style[index] = nextStyle[index];\r\n                                }\r\n                            }\r\n                            next[prop] = { ...prevStyle, ...nextStyle };\r\n                        } else {\r\n                            node.style.cssText = next[prop];\r\n                        }\r\n                    } else {\r\n                        node[prop] = next[prop];\r\n                    }\r\n                } else {\r\n                    if (svg && prop === \"xmlns\") continue;\r\n                    svg\r\n                        ? node.setAttributeNS(null, prop, next[prop])\r\n                        : node.setAttribute(prop, next[prop]);\r\n                }\r\n            } else {\r\n                if (nextMerge) {\r\n                    next[prop] = prev[prop];\r\n                } else {\r\n                    node.removeAttribute(prop);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return props;\r\n}\r\n/**\r\n *\r\n * @param {VDom} vdom - It allows to identify if this node requires the use of a slot\r\n * @param {Object} slots - Object that has living nodes associated by an index\r\n */\r\nfunction slot(vdom, slots) {\r\n    if (vdom.tag === \"slot\") {\r\n        return new VDom(\r\n            slots[vdom.props.name] || \"\",\r\n            vdom.props,\r\n            vdom.children\r\n        );\r\n    }\r\n    return vdom;\r\n}\r\n/**\r\n * Analyze if prev Node has or does not have a state defined by the diff process,\r\n * this is left linked to the node to avoid its loss either by external editing.\r\n *\r\n * @param {HTMLELement} [parent] - If the father is defined, the remove function is activated,\r\n *                                 it allows to remove the nodes from the father\r\n * @param {HTMLELement} [prevNode] - Node that can possess the previous state\r\n * @param {Object} next - Next render state\r\n * @param {Object} slots - Group the slots to be retrieved by the special slot tag\r\n * @param {Boolean} svg - define if the html element is a svg\r\n * @return {HTMLELement} - returns the current node.\r\n */\r\nexport function diff(parent, prevNode, next, slots = {}, svg) {\r\n    let prev = prevNode && prevNode[MASTER] ? prevNode[MASTER] : new VDom(),\r\n        nextNode = prevNode,\r\n        nextMaster = next;\r\n    if (next) {\r\n        next = slot(next, slots);\r\n        prev = slot(prev, slots);\r\n        svg = svg || next.tag === \"svg\";\r\n\r\n        if (parent) {\r\n            if (prev.tag !== next.tag) {\r\n                nextNode = isDom(next.tag)\r\n                    ? next.tag\r\n                    : next.tag\r\n                        ? svg\r\n                            ? document.createElementNS(\r\n                                  \"http://www.w3.org/2000/svg\",\r\n                                  next.tag\r\n                              )\r\n                            : document.createElement(next.tag)\r\n                        : document.createTextNode(\"\");\r\n                if (prevNode) {\r\n                    replace(parent, nextNode, prevNode);\r\n                    while (!nextNode[ELEMENT] && prevNode.firstChild) {\r\n                        append(nextNode, prevNode.firstChild);\r\n                    }\r\n                } else {\r\n                    append(parent, nextNode);\r\n                }\r\n            }\r\n        }\r\n        if (nextNode.nodeType === 3) {\r\n            if (prev.children[0] !== next.children[0])\r\n                nextNode.textContent = next.children[0];\r\n        } else {\r\n            let collect = parent && nextNode[ELEMENT] && nextNode._props.keys,\r\n                props = diffProps(\r\n                    nextNode,\r\n                    next.tag === prev.tag ? prev.props : {},\r\n                    next.props,\r\n                    svg,\r\n                    /**\r\n                     * It allows to obtain properties of the iteration of diff by properties\r\n                     */\r\n                    collect,\r\n                    /**\r\n                     * This allows not to delete the previous state and keep it in the next state\r\n                     */\r\n                    collect\r\n                );\r\n            if (nextNode[ELEMENT] && parent) {\r\n                props.children = next.children.map(\r\n                    vdom => (vdom.tag ? vdom : vdom.children)\r\n                );\r\n                nextNode.setProperties(props);\r\n            } else {\r\n                if (nextNode) {\r\n                    let children = Array.from(nextNode.childNodes),\r\n                        length = Math.max(\r\n                            children.length,\r\n                            next.children.length\r\n                        );\r\n                    for (let i = 0; i < length; i++) {\r\n                        diff(\r\n                            nextNode,\r\n                            children[i],\r\n                            next.children[i],\r\n                            slots,\r\n                            svg\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        if (parent && prevNode) remove(parent, prevNode);\r\n    }\r\n    nextNode[MASTER] = nextMaster;\r\n    return nextNode;\r\n}\r\n","import { ELEMENT, MASTER } from \"./constants\";\r\nimport { h, isVDom } from \"./vdom\";\r\nimport { diff } from \"./diff\";\r\nimport { defer, camelCase, append, getProps } from \"./utils\";\r\n\r\nexport default class extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n\r\n        this[ELEMENT] = true;\r\n\r\n        this.slots = {};\r\n        this.props = { children: [] };\r\n        this.isMount = false;\r\n        this.preventRender = true;\r\n        this.content = document.createDocumentFragment();\r\n\r\n        this._class = this.constructor;\r\n        this._name = this.tagName.toLocaleLowerCase();\r\n        this._props = getProps(this._class.props);\r\n    }\r\n    static get props() {\r\n        return {};\r\n    }\r\n    static get observedAttributes() {\r\n        return getProps(this.props).keys;\r\n    }\r\n    connectedCallback() {\r\n        defer(() => {\r\n            while (this.firstChild) {\r\n                let child = this.firstChild,\r\n                    slot = child.getAttribute && child.getAttribute(\"slot\");\r\n                if (slot) {\r\n                    this.slots[slot] = child;\r\n                }\r\n                append(this.content, child);\r\n            }\r\n            this.preventRender = false;\r\n            this.setState({}, () => {\r\n                this.isMount = true;\r\n                this.elementMount();\r\n            });\r\n        });\r\n    }\r\n    disconnectedCallback() {\r\n        this.elementUnmount();\r\n    }\r\n    attributeChangedCallback(index, prev, next) {\r\n        this.setProperties({ [index]: next });\r\n    }\r\n    setAttribute(prop, value) {\r\n        if (this._props.keys.indexOf(prop) > -1) {\r\n            this.setProperties({ [prop]: value });\r\n        } else {\r\n            super.setAttribute(prop, value);\r\n        }\r\n    }\r\n    setProperties(props) {\r\n        let nextProps = {},\r\n            prevent = this.isMount;\r\n        for (let prop in props) {\r\n            let type = this._props.types[prop],\r\n                value = props[prop],\r\n                index;\r\n            if (type) {\r\n                value = type(value);\r\n            }\r\n            index = camelCase(prop);\r\n            if (value !== this.props[index]) {\r\n                nextProps[index] = value;\r\n            }\r\n        }\r\n        if (Object.keys(nextProps).length) {\r\n            if (prevent)\r\n                prevent = this.elementReceiveProps(nextProps) !== false;\r\n            this.props = { ...this.props, ...nextProps };\r\n            if (prevent) this.setState({});\r\n        }\r\n    }\r\n    setState(state, watch) {\r\n        if (typeof state !== \"object\") return;\r\n        this.state = { ...this.state, ...state };\r\n        if (this.preventRender) return;\r\n        this.preventRender = true;\r\n        defer(() => {\r\n            let render = this.render();\r\n\r\n            if (isVDom(render)) {\r\n                let isHost = render.tag === \"host\";\r\n                render = h(\r\n                    this._name,\r\n                    isHost ? render.props : {},\r\n                    isHost ? render.children : render\r\n                );\r\n            } else {\r\n                render = h(this._name, {}, render);\r\n            }\r\n\r\n            diff(false, this, render, this.slots);\r\n            this.preventRender = false;\r\n            watch ? watch() : this.elementUpdate();\r\n        });\r\n    }\r\n    elementMount() {}\r\n    elementUnmount() {}\r\n    elementUpdate() {}\r\n    elementReceiveProps() {}\r\n    render() {}\r\n}\r\n"],"names":["h","tag","props","VDom","concat","children","this","isDom","nodeType","isVDom","value","merge","let","i","length","child","Array","isArray","push","const","ELEMENT","MASTER","camelCase","string","replace","all","letter","toUpperCase","defer","handler","Promise","resolve","then","root","parent","shadowRoot","remove","removeChild","append","appendChild","newChild","oldChild","replaceChild","getProps","keys","Object","types","diffProps","node","prev","next","svg","collect","nextMerge","prop","indexOf","removeEventListener","addEventListener","prevStyle","nextStyle","index","style","cssText","setAttributeNS","setAttribute","removeAttribute","slot","vdom","slots","name","diff","prevNode","nextNode","nextMaster","document","createElementNS","createElement","createTextNode","firstChild","textContent","_props","map","setProperties","from","childNodes","Math","max","HTMLElement","[object Object]","super","isMount","preventRender","content","createDocumentFragment","_class","constructor","_name","tagName","toLocaleLowerCase","observedAttributes","getAttribute","setState","elementMount","elementUnmount","nextProps","prevent","type","elementReceiveProps","state","watch","render","isHost","elementUpdate"],"mappings":"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"}