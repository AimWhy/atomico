import { Atomico, DOMProps, JSXElements, JSXProps, Nullable } from "./dom";

import {
    FillObject,
    SchemaProps,
    ConstructorType,
    TypeToConstructor,
    SchemaInfer,
} from "./schema";

import { Sheets } from "./css";
import { VNodeKeyTypes, VNode } from "./vnode";
import * as Hooks from "./hooks";

export { DOMEvent, DOMListener, JSXElement } from "./dom";
export { css, Sheet, Sheets } from "./css";
export { html } from "./html";
export * from "./hooks";

/**
 * Identify whether a node in the list belongs to a fragment marker instance
 * ```ts
 * [...element.childNodes].filter(child=>child instanceof Mark);
 * ```
 */
export interface Mark extends Text {}
/**
 * Current will take its value immediately after rendering
 * The whole object is persistent between renders and mutable
 */
export interface Ref<CurrentTarget = any> extends FillObject {
    current?: CurrentTarget extends Atomico<any, any>
        ? InstanceType<CurrentTarget>
        : CurrentTarget;
}

export type Host<Meta> = VNode<any>;

export type SyntheticProps<Props> = {
    [Prop in keyof Props]: Prop extends `on${string}`
        ? {
              type: Function;
              value: (event: Props[Prop]) => any;
          }
        : {
              type: Function;
              value: Props[Prop];
          };
};

export type SyntheticMetaProps<Meta> = {
    [Prop in keyof Meta]?: Prop extends `on${string}`
        ? (event: Meta[Prop]) => any
        : Meta[Prop];
};

export type Type<Types> = TypeToConstructor<Types> & { meta?: Types };

/**
 * Infer the types from `component.props`.
 
 * ```tsx
 * function component({value}: Props<typeof component.props >){
 *      return <host/>
 * }
 *
 * component.props = {value:Number}
 * ```
 */
type GetProps<P> = P extends {
    readonly "##props"?: infer P;
}
    ? P
    : P extends { props: SchemaProps }
    ? GetProps<P["props"]>
    : {
          [K in keyof P]?: P[K] extends {
              type: infer T;
              value: infer V;
          }
              ? FunctionConstructor extends T
                  ? V
                  : V extends () => infer T
                  ? T
                  : V
              : P[K] extends { type: infer T }
              ? ConstructorType<T>
              : ConstructorType<P[K]>;
      };

type ReplaceProps<P, Types> = {
    [I in keyof P]?: I extends keyof Types ? Types[I] : P;
};

/**
 * Infers the props from the component's props object, example:
 * ### Syntax
 * ```tsx
 * const myProps = { message: String }
 * Props<typeof MyProps>;
 * // {message: string}
 * ```
 * ### Usage
 * You can use the `Prop` type on components, objects or constructors, example:
 * ```tsx
 * function component({message}: Props<typeof component>){
 *  return <host></host>
 * }
 *
 * component.props = {message: String}
 * ```
 *
 * ### Advanced use
 *
 * It also allows to replace types of those already inferred, example:
 * ```tsx
 * Props<typeof MyProps, {message: "hello"|"bye bye"}>;
 * // {message?: "hello"|"bye bye"}
 *
 * ```
 */
export type Props<P, Types = null> = Types extends null
    ? GetProps<P>
    : ReplaceProps<GetProps<P>, Types>;

/**
 * metaProps allow to hide the props assigned by Component<props>
 */
interface MetaProps<props> {
    readonly "##props"?: props;
}

/**
 * The MetaComponent type allows to identify as
 * validate types generated by Component<props>
 */
interface MetaComponent {
    (props: any): any;
    props: MetaProps<any>;
    styles?: Sheets;
}

export type Component<props = null, meta = any> = props extends null
    ? {
          (props: FillObject): Host<meta>;
          props?: SchemaProps;
          styles?: Sheets;
      }
    : {
          (props: DOMProps<props>): Host<meta>;
          props: SchemaInfer<props> &
              MetaProps<
                  meta extends null ? props : props & SyntheticMetaProps<meta>
              >;
          styles?: Sheets;
      };

export type CreateElement<C, Base, CheckMeta = true> = CheckMeta extends true
    ? C extends (props: any) => Host<infer Meta>
        ? CreateElement<C & { props: SyntheticProps<Meta> }, Base, false>
        : CreateElement<C, Base, false>
    : C extends { props: infer P }
    ? Atomico<Props<P>, Base>
    : Atomico<{}, Base>;

/**
 * Create the customElement to be declared in the document.
 * ### Usage
 * ```js
 * import {c} from "atomico";
 *
 * function myComponent(){
 *     return <host></host>
 * }
 *
 * customElements.define("my-component", c(myComponent));
 * ```
 * @todo Add a type setting that doesn't crash between JS and template-string.
 */
export function c<
    T extends typeof HTMLElement,
    C extends Component | MetaComponent
>(component: C, BaseElement?: T): CreateElement<C, T>;

export namespace h.JSX {
    interface IntrinsicElements extends JSXElements {
        [tagName: string]: any;
    }
}

/**
 * function-pragma, create the vnode
 */
export function h<Type extends VNodeKeyTypes>(
    type: Type,
    props?: Nullable<JSXProps<Type>>,
    ...children: any[]
): VNode<Type, any, any[]>;

/**
 * VirtualDOM rendering function
 * ```jsx
 * render(h("host"),document.querySelector("#app"))
 * render(<host/>,document.querySelector("#app"))
 * render(html`<host/>`,document.querySelector("#app"))
 * ```
 */
export function render<T = Element>(
    VNode: VNode<"host", any, any>,
    node: T,
    id?: string | symbol
): T;

/**
 * dispatch an event from the custom Element.
 * ###  Usage
 * ```js
 * const dispatchChangeValue = useEvent("changeValue")
 * const dispatchChangeValueToParent = useEvent("changeValue", {bubbles:true})
 * ```
 *
 * By using typescript you can define the type as a parameter for the dispatch to be created by useEvent, example::
 *
 * ```tsx
 * const dispatch = useEvent<{id: string}>("changeValue", {bubbles:true});
 *
 * function handler(){
 *      dispatch({id:10}) // Typescript will check the dispatch parameter
 * }
 * ```
 */
export const useEvent: Hooks.UseEvent;

/**
 * Similar to useState, but with the difference that useProp reflects the effect as component property
 * ```js
 * function component(){
 *     const [ myProp, setMyProp ] = useProp<string>("myProp");
 *     return <host>{ myProp }</host>;
 * }
 *
 * component.props = { myProp : String }
 * ```
 */
export const useProp: Hooks.UseProp;

/**
 * create a private state in the customElement
 * ```js
 * function component(){
 *     const [ count, setCount ] = useState(0);
 *     return <host>{ count }</host>;
 * }
 * ```
 */
export const useState: Hooks.UseState;

/**
 * Create or recover a persistent reference between renders.
 * ```js
 * const ref = useRef();
 * ```
 */
export const useRef: Hooks.UseRef;

/**
 * Memorize the return of a callback based on a group of arguments,
 * the callback will be executed only if the arguments change between renders
 * ```js
 * const value = useMemo(expensiveProcessesCallback)
 * ```
 */
export const useMemo: Hooks.UseMemo;

/**
 * Memorize the creation of a callback to a group of arguments,
 * The callback will preserve the scope of the observed arguments
 * ```js
 * const callback = useCallback((user)=>addUser(users, user),[users]);
 * ```
 */
export const useCallback: Hooks.UseCallback;
/**
 * Evaluate the execution of a callback after each render cycle,
 * if the arguments between render do not change the callback
 * will not be executed, If the callback returns a function
 * it will be executed as an effect collector
 */
export const useEffect: Hooks.UseEffect;

/**
 * Evaluate the execution of a callback after each render cycle,
 * if the arguments between render do not change the callback
 * will not be executed, If the callback returns a function
 * it will be executed as an effect collector
 */
export const useLayoutEffect: Hooks.UseLayoutEffect;

/**
 * Lets you use the redux pattern as Hook
 */
export const useReducer: Hooks.UseReducer;

/**
 * return to the webcomponent instance for reference
 * ```jsx
 * const ref = useHost();
 * useEffect(()=>{
 *    const {current} = ref;
 *    current.addEventListener("click",console.log);
 * });
 * ```
 */
export const useHost: Hooks.UseHost;

/**
 * Generate an update request to the webcomponent.
 */
export const useUpdate: Hooks.UseUpdate;

/**
 * This hook is low level, it allows to know the render cycles of the hooks
 * @param render - callback that runs between renders
 * @param layoutEffect - callback that is executed after rendering
 * @param effect - callback that is executed after layoutEffect
 */
export const useHook: Hooks.UseHook;

export interface Options {
    sheet: boolean;
    ssr?: boolean;
    render?: <T = ChildNode>(
        node: T,
        id?: symbol | string,
        hidrate?: boolean
    ) => T;
}

/**
 * customize Atomico behavior for non-browser environments,
 * example SSR in node
 */
export const options: Options;

/**
 * Create a template to reuse as a RAW node, example:
 * ```tsx
 * const StaticNode = template(<svg>...</svg>);
 *
 * function component(){
 *      return <host>
 *          <StaticNode cloneNode></StaticNode>
 *      </host>
 * }
 * ```
 */
export function template<T = Element>(vnode: any): T;
