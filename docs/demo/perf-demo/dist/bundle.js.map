{"version":3,"file":"bundle.js","sources":["../../../../src/constants.js","../../../../src/options.js","../../../../src/utils.js","../../../../src/vnode.js","../../../../src/updateChildren.js","../../../../src/updateStyle.js","../../../../src/updateEvent.js","../../../../src/updateProperties.js","../../../../src/task.js","../../../../src/component.js","../../../../src/update.js","../../../../src/hooks.js","../src/dot.js","../src/triangle.js","../src/index.js"],"sourcesContent":["export const NODE_TEXT = \"#text\";\r\nexport const NODE_HOST = \"host\";\r\n\r\nexport const TAG_VALUE = \"@tag\";\r\n\r\nexport const CSS_VALUE = \"@css\";\r\n\r\nexport const ATTRS_VALUE = \"@attrs\";\r\n\r\nexport const SHADOWDOM = \"shadowDom\";\r\n\r\nexport const COMPONENT_CREATE = \"@create\";\r\nexport const COMPONENT_UPDATE = \"@update\";\r\nexport const COMPONENT_CREATED = \"@created\";\r\nexport const COMPONENT_UPDATED = \"@updated\";\r\nexport const COMPONENT_CLEAR = \"@clear\";\r\nexport const COMPONENT_REMOVE = \"@remove\";\r\n/**\r\n * if a list of children is empty in content it is\r\n * replaced by this constant with the intention\r\n * of simplifying the immutable comparison\r\n */\r\nexport const EMPTY_CHILDREN = [];\r\n/**\r\n * stores the transformations created in update Event,\r\n * by manipulating the name of the event\r\n */\r\nexport const EVENT_ALIAS = {};\r\n\r\nexport const CONTEXT = \"@ctx.\";\r\n","export let options = {\r\n    // defines the maximum amount of simultaneous tasks\r\n    maxConcurrentTask: 5000\r\n};\r\n","/**\r\n * Return if value is array\r\n * @param {*}\r\n * @return {boolean}\r\n */\r\nexport function isArray(value) {\r\n    return Array.isArray(value);\r\n}\r\n/**\r\n * compare 2 array\r\n * @param {array} before\r\n * @param {array} after\r\n * @example\r\n * isEqualArray([1,2,3,4],[1,2,3,4]) // true\r\n * isEqualArray([1,2,3,4],[1,2,3])   // false\r\n * isEqualArray([5,1,2,3],[1,2,3,5]) // false\r\n * isEqualArray([],[]) // true\r\n * @returns {boolean}\r\n */\r\nexport function isEqualArray(before, after) {\r\n    let length = before.length;\r\n    if (length !== after.length) return false;\r\n    for (let i = 0; i < length; i++) {\r\n        if (before[i] !== after[i]) return false;\r\n    }\r\n    return true;\r\n}\r\n","import { isArray } from \"./utils\";\r\nimport { EMPTY_CHILDREN, SHADOWDOM } from \"./constants\";\r\n/**\r\n * allows to transfer the arguments to createVnode\r\n * @param {string|function} tag - define the vnode to work\r\n * @param {object} [props] - vnode properties\r\n * @param {array} [children] - properties to be transmitted to the vnode\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return createVnode(tag, props, children);\r\n}\r\n/**\r\n * if the vnode is defined different from an object, it returns a vnode that creates a text node\r\n * @param {*} value\r\n * @return {object}\r\n */\r\nexport function defineVnode(value) {\r\n    let type = typeof value;\r\n    if (value && type === \"object\" && value.tag) {\r\n        return value;\r\n    } else {\r\n        return {\r\n            tag: \"#text\",\r\n            children: type === \"number\" || type === \"string\" ? \"\" + value : \"\"\r\n        };\r\n    }\r\n}\r\n/**\r\n * create a representative object of the node to be created, updated or deleted\r\n * @param {string|function} tag - type of node to represent\r\n * @param {object} nextProps - properties of the node to represent\r\n * @param {array} nextChildren - children of the node to represent\r\n */\r\nexport function createVnode(tag, nextProps, nextChildren) {\r\n    nextProps = nextProps || {};\r\n    // Increase the indexes to be reused.\r\n    let useKeys,\r\n        // key identifier\r\n        key,\r\n        // list of children\r\n        children,\r\n        // amount of props\r\n        size = 1,\r\n        // Tag properties\r\n        props = {},\r\n        // define whether the node will update the context\r\n        useContext,\r\n        // announces that the node will use shadowDom\r\n        useShadowDom,\r\n        // lets you ignore updateChildren\r\n        useChildren = true,\r\n        // scan the children recursively to form a list without depth\r\n        mapChildren = (nextChildren, deep = 0, children = []) => {\r\n            let length = nextChildren.length,\r\n                recicleChildren = true;\r\n            // allows recycling to nextChildren, if the condition is met\r\n            while (!deep && length === 1 && isArray(nextChildren[0])) {\r\n                nextChildren = nextChildren[0];\r\n                length = nextChildren.length;\r\n            }\r\n\r\n            if (!length) return EMPTY_CHILDREN;\r\n\r\n            for (let i = 0; i < length; i++) {\r\n                let child = nextChildren[i];\r\n                if (isArray(child)) {\r\n                    mapChildren(child, deep + 1, children);\r\n                    recicleChildren = false;\r\n                } else {\r\n                    let childType = typeof child;\r\n                    if (\r\n                        child &&\r\n                        childType === \"object\" &&\r\n                        child.key !== undefined\r\n                    ) {\r\n                        useKeys = useKeys || {};\r\n                        if (child.key in useKeys) {\r\n                            throw new Error(\r\n                                \"Each key must be unique among children\"\r\n                            );\r\n                        } else {\r\n                            useKeys[child.key] = true;\r\n                        }\r\n                    } else {\r\n                        if (useKeys) {\r\n                            throw new Error(\"Each child must have a key\");\r\n                        }\r\n                    }\r\n                    children.push(child);\r\n                }\r\n            }\r\n            return recicleChildren ? nextChildren : children;\r\n        };\r\n\r\n    for (let index in nextProps) {\r\n        let value = nextProps[index];\r\n        switch (index) {\r\n            case \"context\":\r\n                if (typeof value === \"object\") useContext = value;\r\n                continue;\r\n            case \"children\":\r\n                if (value === false) useChildren = false;\r\n                nextChildren = value;\r\n                continue;\r\n            case \"innerHTML\":\r\n            case \"textContent\":\r\n            case \"contenteditable\":\r\n                useChildren = false;\r\n                break;\r\n            case \"class\":\r\n                index = \"className\";\r\n                break;\r\n            case SHADOWDOM:\r\n                useShadowDom = value;\r\n                break;\r\n            case \"key\":\r\n                index = \"data-key\";\r\n                break;\r\n        }\r\n        props[index] = value;\r\n        size++;\r\n    }\r\n\r\n    // children is empty, it is replaced by the constant, in order to compare the empty state\r\n    props.children = children = mapChildren(nextChildren);\r\n\r\n    return {\r\n        tag,\r\n        key,\r\n        size,\r\n        props,\r\n        children,\r\n        useKeys,\r\n        useContext,\r\n        useChildren,\r\n        useShadowDom\r\n    };\r\n}\r\n","import { update, createNode } from \"./update\";\r\nimport { defineVnode } from \"./vnode\";\r\nimport { NODE_TEXT, COMPONENT_REMOVE } from \"./constants\";\r\n/**\r\n * issue elimination to the entire tree of nodes\r\n * @param {string} ID\r\n * @param {HTMLElement|SVGElement|Text} node\r\n */\r\nexport function clearNode(ID, node) {\r\n    let { dispatch } = node[ID] || {},\r\n        nodeList = node.childNodes,\r\n        length = nodeList.length;\r\n    if (dispatch) dispatch(COMPONENT_REMOVE);\r\n    for (let i = 0; i < length; i++) {\r\n        clearNode(ID, nodeList[i]);\r\n    }\r\n}\r\n/**\r\n *\r\n * @param {string} ID\r\n * @param {HTMLElement|SVGElement|Text} node - node to extract current children\r\n * @param {object} vnextChildren  - list of children to update\r\n * @param {object|undefined} useKeys - index of keys to keep in the next update\r\n * @param {boolean} isSvg - define if it is a svg tree\r\n * @param {object} context - current context to share\r\n * @return {HTMLElement|SVGElement|Text}\r\n */\r\nexport function updateChildren(\r\n    ID,\r\n    node,\r\n    vnextChildren,\r\n    useKeys,\r\n    isSvg,\r\n    context\r\n) {\r\n    let nodeKeys = {},\r\n        nodeList = node.childNodes,\r\n        nodeListLength = nodeList.length,\r\n        vnodeListLength = vnextChildren.length,\r\n        /**\r\n         * modifies the start of the iteration based on the type whether it is using keys or indexes\r\n         * this is done for a deletion without iterate completely nodeList\r\n         */\r\n        nodeListIndexStart = useKeys\r\n            ? 0\r\n            : nodeListLength > vnodeListLength\r\n            ? vnodeListLength\r\n            : nodeListLength;\r\n    for (; nodeListIndexStart < nodeListLength; nodeListIndexStart++) {\r\n        let nodeChild = nodeList[nodeListIndexStart],\r\n            isRemove,\r\n            key = nodeListIndexStart;\r\n        // if the iteration uses keys, the node is stored in the index corresponding to its key\r\n        if (useKeys) {\r\n            key = nodeChild.dataset.key;\r\n            if (key in useKeys) {\r\n                nodeKeys[key] = nodeChild;\r\n            } else {\r\n                isRemove = true;\r\n            }\r\n        } else {\r\n            isRemove = true;\r\n        }\r\n        if (nodeChild && isRemove) {\r\n            clearNode(ID, nodeChild);\r\n            nodeListLength--;\r\n            nodeListIndexStart--;\r\n            node.removeChild(nodeChild);\r\n        }\r\n    }\r\n    for (let i = 0; i < vnodeListLength; i++) {\r\n        let vnode = defineVnode(vnextChildren[i]),\r\n            nextSibling = nodeList[i + 1],\r\n            useKey = useKeys ? vnode.key : i,\r\n            indexChild = nodeList[i],\r\n            prevChild = useKeys ? nodeKeys[vnode.key] : indexChild;\r\n\r\n        if (useKeys) {\r\n            if (prevChild !== indexChild) {\r\n                node.insertBefore(prevChild, indexChild);\r\n            }\r\n        }\r\n\r\n        // if it is a component and it does not have an associative node, it will create one to work within update\r\n        if (typeof vnode.tag === \"function\") {\r\n            if (!prevChild) {\r\n                prevChild = createNode(NODE_TEXT);\r\n                if (nextSibling) {\r\n                    node.insertBefore(prevChild, nextSibling);\r\n                } else {\r\n                    node.appendChild(prevChild);\r\n                }\r\n            }\r\n        }\r\n\r\n        let nextNode = update(ID, prevChild, vnode, isSvg, context);\r\n\r\n        if (!prevChild) {\r\n            if (nextSibling) {\r\n                node.insertBefore(nextNode, nextSibling);\r\n            } else {\r\n                node.appendChild(nextNode);\r\n            }\r\n        }\r\n    }\r\n}\r\n","/**\r\n * memorizes the transformations associated with the css properties.\r\n * @example\r\n * {borderRadius:\"50px\"} // {\"border-radius\" : \"50px\"}\r\n */\r\nconst CSS_PROPS = {};\r\n\r\n/**\r\n * Define the style property immutably\r\n * @param {HTMLElement|SVGAElement} node\r\n * @param {object|string} nextValue\r\n */\r\nexport function updateStyle(node, prevValue, nextValue) {\r\n    // this function has the previous state of the css directly from the node by the constant [CSS_VALUE]\r\n    let prevCss = prevValue,\r\n        nextCss = nextValue;\r\n    if (typeof nextValue === \"object\") {\r\n        nextCss = \"\";\r\n        for (let key in nextValue) {\r\n            if (!nextValue[key]) continue;\r\n            if (!CSS_PROPS[key]) {\r\n                CSS_PROPS[key] = key.replace(\r\n                    /([^A-Z])([A-Z])/g,\r\n                    (all, letterBefore, letterAfter) =>\r\n                        letterBefore + \"-\" + letterAfter.toLowerCase()\r\n                );\r\n            }\r\n            nextCss += `${CSS_PROPS[key]}:${nextValue[key]};`;\r\n        }\r\n    }\r\n\r\n    if (prevCss !== nextCss) {\r\n        node.style.cssText = nextCss;\r\n    }\r\n\r\n    return nextCss;\r\n}\r\n","import { options } from \"./options\";\r\nimport { EVENT_ALIAS } from \"./constants\";\r\n\r\nexport function updateEvent(node, type, prevHandler, nextHandler, handlers) {\r\n    if (type[0] !== \"o\" && type[1] !== \"n\") return;\r\n\r\n    if (!EVENT_ALIAS[type])\r\n        EVENT_ALIAS[type] = type.slice(2).toLocaleLowerCase();\r\n\r\n    type = EVENT_ALIAS[type];\r\n    if (!handlers[type]) {\r\n        handlers[type] = [event => handlers[type][1].call(event.target, event)];\r\n    }\r\n    let eventProxy = handlers[type][0];\r\n    if (prevHandler && !nextHandler) {\r\n        node.removeEventListener(type, eventProxy);\r\n        delete handlers[type];\r\n    } else {\r\n        if (!prevHandler && nextHandler) {\r\n            node.addEventListener(type, eventProxy);\r\n        }\r\n        handlers[type][1] = nextHandler;\r\n    }\r\n}\r\n","import { updateStyle } from \"./updateStyle\";\r\nimport { updateEvent } from \"./updateEvent\";\r\nimport { ATTRS_VALUE, SHADOWDOM } from \"./constants\";\r\n// properties to ignore by updateProperties\r\nconst IGNORE = {\r\n    children: 1\r\n};\r\n\r\nfunction removeAttribute(node, isSvg, key) {\r\n    node.removeAttribute(isSvg && key === \"xlink\" ? \"xlink:href\" : key);\r\n}\r\n/**\r\n * define the properties of the node\r\n * @param {HTMLElement|SVGAElement} node\r\n * @param {object} nextProps\r\n * @param {boolean} isSvg\r\n */\r\nexport function updateProperties(node, prevProps, nextProps, handlers, isSvg) {\r\n    prevProps = prevProps || {};\r\n    // currentProps, allows to isolate the manipulated properties,\r\n    // to sustain a process of parallel states without conflict\r\n    let currentProps = node[ATTRS_VALUE] || {};\r\n    for (let key in prevProps) {\r\n        // IGNORE allows you to ignore a property.\r\n        if (IGNORE[key]) continue;\r\n        // If the property does not exist in the following definition, it is eliminated\r\n        if (!(key in nextProps) && key in currentProps) {\r\n            if (key in node) {\r\n                node[key] = null;\r\n            } else {\r\n                removeAttribute(node, isSvg, key);\r\n            }\r\n            delete currentProps[key];\r\n        }\r\n    }\r\n    for (let key in nextProps) {\r\n        // IGNORE allows you to ignore a property.\r\n        if (IGNORE[key]) continue;\r\n\r\n        let merge = true;\r\n\r\n        let nextValue = nextProps[key],\r\n            typeNextValue = typeof nextValue;\r\n        // get the previous value either from handlers or currentProps\r\n        let prevValue = key in handlers ? handlers[key] : currentProps[key],\r\n            typePrevValue = typeof prevValue;\r\n        // define undefined as value for empty comparison\r\n        nextValue =\r\n            nextValue === null || nextValue === undefined\r\n                ? undefined\r\n                : nextValue;\r\n\r\n        if (nextValue === prevValue) continue;\r\n\r\n        // updates the state of the ref object\r\n        if (key === \"ref\") {\r\n            if (nextValue) nextValue.current = node;\r\n            continue;\r\n        }\r\n\r\n        // Enables the use of shadowDom over the node\r\n        if (SHADOWDOM === key && \"attachShadow\" in node) {\r\n            if (\r\n                (node.shadowRoot && !nextValue) ||\r\n                (!node.shadowRoot && nextValue)\r\n            ) {\r\n                node.attachShadow({ mode: nextValue ? \"open\" : \"closed\" });\r\n            }\r\n            continue;\r\n        }\r\n\r\n        if (typeNextValue === \"function\" || typePrevValue === \"function\") {\r\n            updateEvent(node, key, prevValue, nextValue, handlers);\r\n            merge = false;\r\n        } else if (\r\n            nextValue !== undefined &&\r\n            ((key in node && !isSvg) || (isSvg && key === \"style\"))\r\n        ) {\r\n            if (key === \"style\") {\r\n                nextValue = updateStyle(\r\n                    node,\r\n                    prevValue || node.style.cssText,\r\n                    nextValue\r\n                );\r\n            } else {\r\n                node[key] = nextValue;\r\n            }\r\n        } else if (nextValue) {\r\n            isSvg\r\n                ? node.setAttributeNS(\r\n                      isSvg && key === \"xlink\"\r\n                          ? \"http://www.w3.org/1999/xlink\"\r\n                          : null,\r\n                      key === \"xlink\" ? \"xlink:href\" : key,\r\n                      nextValue\r\n                  )\r\n                : node.setAttribute(key, nextValue);\r\n        } else {\r\n            // proceeds to remove the node attribute and remove the currentProps registry\r\n            removeAttribute(node, isSvg, key);\r\n            delete currentProps[key];\r\n            merge = false;\r\n        }\r\n        if (merge) {\r\n            currentProps[key] = nextValue;\r\n        }\r\n    }\r\n    node[ATTRS_VALUE] = currentProps;\r\n}\r\n","import { options } from \"./options\";\r\nlet task = [],\r\n    defer = Promise.resolve();\r\n/**\r\n * allows to solve the pending tasks\r\n */\r\nfunction resolve() {\r\n    let currentTask = task,\r\n        length = currentTask.length;\r\n\r\n    task = [];\r\n\r\n    for (let i = 0; i < length; i++) {\r\n        let item = currentTask[i];\r\n        // discounts a level to the pending task, if it reaches 0 it is executed\r\n        if (--item.lvl) {\r\n            item.fun(item.arg);\r\n        } else {\r\n            // if the number of queued tasks is greater than\r\n            // options.maxConcurrentTask, the subsequent queue will be left\r\n            if (task.length > options.maxConcurrentTask) item.lvl++;\r\n            // Rescue the task to add it to the next queue\r\n            task.push(item);\r\n        }\r\n    }\r\n    // If there are remaining tasks, generate another cycle to clean the tasks\r\n    if (task.length) defer.then(resolve); //;setTimeout(() => defer.then(resolve));\r\n}\r\n/**\r\n * add a task to the waiting list\r\n * @param {function} fun - function to execute once the task has been solved.\r\n * @param {*} [arg] - argument to deliver to the task, once it is resolved\r\n * @param {number} [lvl] - level of importance 1 is important 2 is less important and so on\r\n */\r\nexport function setTask(fun, arg, lvl = 1) {\r\n    let length = task.length;\r\n    //if (length > options.maxConcurrentTask) lvl++;\r\n    task.push({ fun, arg, lvl });\r\n    // a cycle is created only if there is not one running\r\n    if (!length) {\r\n        defer.then(resolve);\r\n    }\r\n}\r\n","import { setTask } from \"./task\";\r\nimport {\r\n    COMPONENT_CREATE,\r\n    COMPONENT_UPDATE,\r\n    COMPONENT_CREATED,\r\n    COMPONENT_UPDATED,\r\n    COMPONENT_REMOVE\r\n} from \"./constants\";\r\n\r\nimport { update as updateNode } from \"./update\";\r\n\r\nlet CURRENT_SNAP, CURRENT_SNAP_KEY_HOOK;\r\n\r\nexport function getCurrentSnap() {\r\n    if (!CURRENT_SNAP) {\r\n        throw new Error(\r\n            \"the hooks can only be called from an existing functional component in the diff queue\"\r\n        );\r\n    }\r\n    return CURRENT_SNAP;\r\n}\r\n\r\nexport function useHook(reducer) {\r\n    let component = getCurrentSnap().component,\r\n        index = CURRENT_SNAP_KEY_HOOK++,\r\n        hook,\r\n        isCreate;\r\n    if (!component.hooks[index]) {\r\n        isCreate = true;\r\n        component.hooks[index] = {};\r\n    }\r\n    hook = component.hooks[index];\r\n    hook.reducer = reducer;\r\n    if (isCreate) dispatchHook(hook, { type: COMPONENT_CREATE });\r\n    return [hook.state, action => dispatchHook(hook, action)];\r\n}\r\n\r\nexport function dispatchHook(hook, action) {\r\n    hook.state = hook.reducer(hook.state, action);\r\n}\r\n\r\nexport function dispatchComponents(components, action) {\r\n    let length = components.length;\r\n    for (let i = 0; i < length; i++) {\r\n        let component = components[i],\r\n            hooks = component.hooks,\r\n            hooksLength = hooks.length;\r\n        if (action.type === COMPONENT_REMOVE) {\r\n            component.remove = true;\r\n        }\r\n        for (let i = 0; i < hooksLength; i++) {\r\n            dispatchHook(hooks[i], action);\r\n        }\r\n    }\r\n}\r\n/**\r\n * this function allows creating a block that analyzes the tag\r\n * defined as a function, in turn creates a global update scope for hook management.\r\n */\r\nexport function createUpdateComponent(ID, isSvg) {\r\n    let prevent,\r\n        store = [],\r\n        host;\r\n    /**\r\n     * This function allows reducing the functional components based on\r\n     * their return, in turn creates a unique state for each component\r\n     * according to a depth index\r\n     * @param {function} vnode\r\n     * @param {object} context\r\n     * @param {number} deep\r\n     */\r\n    function reduce(vnode, context, deep) {\r\n        // if host does not exist as a node, the vnode is not reduced\r\n        if (!host) return;\r\n        vnode = vnode || \"\";\r\n        // if it is different from a functional node, it is sent to updateNode again\r\n        if (typeof vnode.tag !== \"function\") {\r\n            dispatchComponents(store.splice(deep), {\r\n                type: COMPONENT_REMOVE\r\n            });\r\n            host = updateNode(ID, host, vnode, isSvg, context, updateComponent);\r\n            // if the store no longer has a length, it is assumed that the updateComponent is no longer necessary\r\n            if (store.length) host[ID].updateComponent = updateComponent;\r\n\r\n            return;\r\n        }\r\n        // you get the current component\r\n        let component = store[deep] || {},\r\n            isCreate,\r\n            useNext;\r\n        // if the current component is dis- torted to the analyzed one,\r\n        // the previous state is replaced with a new one and the elimination is dispatched.\r\n        if (component.tag !== vnode.tag) {\r\n            isCreate = true;\r\n            // the state of the component is defined\r\n            store[deep] = {\r\n                lvl: 1,\r\n                size: 1,\r\n                tag: vnode.tag,\r\n                hooks: [],\r\n                props: {},\r\n                context: {}\r\n            };\r\n            // the elimination is sent to the successors of the previous component\r\n            dispatchComponents(store.splice(deep + 1), {\r\n                type: COMPONENT_REMOVE\r\n            });\r\n            useNext = true;\r\n        }\r\n\r\n        component = store[deep];\r\n        // then a series of simple processes are carried out capable of\r\n        // identifying if the component requires an update\r\n        if (component.context !== vnode.useContext) {\r\n            // the current context is stored in the cache\r\n            component.context = vnode.useContext;\r\n            // create a new context\r\n            context = { ...context, ...vnode.useContext };\r\n            useNext = true;\r\n        }\r\n\r\n        if (!useNext) {\r\n            // compare the lake of properties\r\n            if (vnode.size !== component.size) useNext = true;\r\n            if (!useNext) {\r\n                // buy property by property, so the properties to be used\r\n                // in the areas must be immutable\r\n                for (let key in vnode.props) {\r\n                    if (vnode.props[key] !== component.props[key]) {\r\n                        useNext = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        component.props = vnode.props;\r\n        component.size = vnode.size;\r\n        /**\r\n         * this function is a snapshot of the current component,\r\n         * allows to run the component and launch the next update\r\n         */\r\n        function next() {\r\n            if (component.remove) return host;\r\n\r\n            CURRENT_SNAP = {\r\n                component,\r\n                context,\r\n                // allows access to the instantaneous, but it uses the microtareas\r\n                // to prevent multiple synchronous updates\r\n                next() {\r\n                    if (!component.prevent) {\r\n                        component.prevent = true;\r\n                        setTask(() => {\r\n                            component.prevent = false;\r\n                            next();\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n\r\n            CURRENT_SNAP_KEY_HOOK = 0;\r\n\r\n            dispatchComponents([component], { type: COMPONENT_UPDATE });\r\n\r\n            let vnextnode = component.tag(component.props, context);\r\n\r\n            CURRENT_SNAP = false;\r\n            CURRENT_SNAP_KEY_HOOK = 0;\r\n\r\n            reduce(vnextnode, context, deep + 1);\r\n\r\n            dispatchComponents([component], {\r\n                type: isCreate ? COMPONENT_CREATED : COMPONENT_UPDATED\r\n            });\r\n\r\n            isCreate = false;\r\n        }\r\n\r\n        if (useNext && !component.prevent) next();\r\n    }\r\n    /**\r\n     *\r\n     * @param {string} type\r\n     * @param {HTMLElement|SVGElement|Text} nextHost\r\n     * @param {object} vnode\r\n     * @param {object} context\r\n     */\r\n    function updateComponent(type, nextHost, vnode, context) {\r\n        switch (type) {\r\n            case COMPONENT_UPDATE:\r\n                host = nextHost;\r\n                reduce(vnode, context, 0);\r\n                return host;\r\n            case COMPONENT_REMOVE:\r\n                host = false;\r\n                dispatchComponents(history, { type });\r\n                history = [];\r\n                break;\r\n        }\r\n    }\r\n\r\n    return updateComponent;\r\n}\r\n","import { NODE_TEXT, NODE_HOST, TAG_VALUE, COMPONENT_UPDATE } from \"./constants\";\r\nimport { options } from \"./options\";\r\nimport { defineVnode } from \"./vnode\";\r\nimport { updateChildren } from \"./updateChildren\";\r\nimport { updateProperties } from \"./updateProperties\";\r\nimport { createUpdateComponent } from \"./component\";\r\nimport { setTask } from \"./task\";\r\nimport { createVnode } from \"./vnode\";\r\n/**\r\n * @param {object} vnode\r\n * @param {HTMLElement|SVGElement} node\r\n * @param {string} [customID]\r\n * @param {boolean} disableHost\r\n */\r\nexport function render(vnode, node, disableHost, customID = \"@vn\") {\r\n    if (!disableHost) {\r\n        vnode = defineVnode(vnode);\r\n        if (vnode.tag !== NODE_HOST) {\r\n            vnode = createVnode(NODE_HOST, {}, [vnode]);\r\n        }\r\n    }\r\n    update(customID, node, vnode);\r\n}\r\n\r\nexport function createNode(tag, isSvg) {\r\n    let doc = options.document || document,\r\n        nextNode;\r\n    if (tag !== NODE_TEXT) {\r\n        nextNode = isSvg\r\n            ? doc.createElementNS(\"http://www.w3.org/2000/svg\", tag)\r\n            : doc.createElement(tag);\r\n    } else {\r\n        nextNode = doc.createTextNode(\"\");\r\n    }\r\n    nextNode[TAG_VALUE] = tag;\r\n    return nextNode;\r\n}\r\n\r\nexport function getNodeName(node) {\r\n    if (!node) return;\r\n    // store the process locally in the node to avoid transformation\r\n    if (!node[TAG_VALUE]) {\r\n        node[TAG_VALUE] = node.nodeName.toLowerCase();\r\n    }\r\n    return node[TAG_VALUE];\r\n}\r\n/**\r\n *\r\n * @param {string} ID - store the process locally in the node to avoid transformation\r\n * @param {HTMLElement|SVGElement|Text|undefined} prevNode - if the current node is defined and the next\r\n * one to be used is different, the replacement of the current node will be made\r\n * @param {*} vnode\r\n * @param {boolean} isSvg\r\n * @param {object} context\r\n * @param {function|undefined} currentUpdateComponent\r\n */\r\nexport function update(\r\n    ID,\r\n    prevNode,\r\n    vnode,\r\n    isSvg,\r\n    context,\r\n    currentUpdateComponent\r\n) {\r\n    // get a node object\r\n    vnode = defineVnode(vnode);\r\n    // if the previous state exists, it obtains the state\r\n    let { vnode: vprevnode = {}, handlers = {}, updateComponent } =\r\n        (prevNode && prevNode[ID]) || {};\r\n    // if the node stored in the previous state is identical to the current one,\r\n    // it will not execute the update process\r\n    if (vnode === vprevnode) return prevNode;\r\n\r\n    let {\r\n        // defines the next node to manipulate the concurrent tree\r\n        tag: nextTag,\r\n        // define the properties that the next node must possess\r\n        props: nextProps,\r\n        // define the children that this node must possess in the following state\r\n        children: nextChildren,\r\n        // transmits keys to the updateChildren that is kept in the children list\r\n        useKeys,\r\n        // define if they would use updateChildren\r\n        useChildren,\r\n        // define if shadowDom was used\r\n        useShadowDom\r\n    } = vnode;\r\n    // define if the tree is of the SVG type\r\n    isSvg = isSvg || nextTag === \"svg\";\r\n\r\n    let nextNode = prevNode,\r\n        isFunction = typeof nextTag === \"function\";\r\n\r\n    // create an updateComponent\r\n    if (isFunction && !updateComponent) {\r\n        updateComponent = createUpdateComponent(ID, isSvg);\r\n    }\r\n\r\n    if (\r\n        getNodeName(prevNode) !== nextTag &&\r\n        nextTag !== \"host\" &&\r\n        !isFunction\r\n    ) {\r\n        nextNode = createNode(nextTag, isSvg);\r\n        handlers = {};\r\n        let parent = prevNode && prevNode.parentNode;\r\n        if (parent) parent.replaceChild(nextNode, prevNode);\r\n    }\r\n    if (updateComponent && currentUpdateComponent !== updateComponent) {\r\n        return updateComponent(COMPONENT_UPDATE, nextNode, vnode, context);\r\n    } else if (nextTag !== NODE_TEXT) {\r\n        updateProperties(nextNode, vprevnode.props, nextProps, handlers, isSvg);\r\n        if (useChildren && vprevnode.children !== vnode.children) {\r\n            updateChildren(\r\n                ID,\r\n                useShadowDom ? nextNode.shadowRoot || nextNode : nextNode,\r\n                nextChildren,\r\n                useKeys,\r\n                isSvg,\r\n                context\r\n            );\r\n        }\r\n    } else {\r\n        if (nextNode.nodeValue !== nextChildren) {\r\n            nextNode.nodeValue = nextChildren;\r\n        }\r\n    }\r\n\r\n    nextNode[ID] = { handlers, vnode, updateComponent };\r\n\r\n    return nextNode;\r\n}\r\n","import { getCurrentSnap, useHook } from \"./component\";\r\n\r\nimport { isEqualArray } from \"./utils\";\r\n\r\nimport {\r\n    COMPONENT_CREATE,\r\n    COMPONENT_CREATED,\r\n    COMPONENT_UPDATE,\r\n    COMPONENT_UPDATED,\r\n    COMPONENT_REMOVE,\r\n    COMPONENT_CLEAR\r\n} from \"./constants\";\r\n\r\nexport function useState(initialState) {\r\n    let next = getCurrentSnap().next,\r\n        type = \"useState/update\";\r\n    let [state, dispatch] = useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n                return typeof initialState === \"function\"\r\n                    ? initialState()\r\n                    : initialState;\r\n            case type:\r\n                let nextState = action.state;\r\n                return typeof nextState === \"function\"\r\n                    ? nextState(state)\r\n                    : nextState;\r\n        }\r\n        return state;\r\n    });\r\n    return [\r\n        state,\r\n        state => {\r\n            dispatch({ state, type });\r\n            next();\r\n        }\r\n    ];\r\n}\r\n\r\nexport function useEffect(callback, args) {\r\n    useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n                return { args };\r\n            case COMPONENT_UPDATE:\r\n            case COMPONENT_REMOVE:\r\n                if (state.clear) {\r\n                    let next =\r\n                        action.type === COMPONENT_REMOVE ||\r\n                        (args && state.args\r\n                            ? !isEqualArray(args, state.args)\r\n                            : true);\r\n                    if (next) state.clear();\r\n                }\r\n                return { ...state, args };\r\n            case COMPONENT_CREATED:\r\n            case COMPONENT_UPDATED:\r\n                let next =\r\n                        action.type === COMPONENT_CREATED ||\r\n                        (args && state.args\r\n                            ? !isEqualArray(args, state.args)\r\n                            : true),\r\n                    clear = state.clear;\r\n                if (next) {\r\n                    clear = callback();\r\n                }\r\n                return { ...state, clear, args };\r\n        }\r\n        return state;\r\n    });\r\n}\r\n\r\nexport function useRef(current) {\r\n    let [state] = useHook((state = {}, action) =>\r\n        action.type === COMPONENT_CREATE ? { current } : state\r\n    );\r\n    return state;\r\n}\r\n\r\nexport function useMemo(callback, args) {\r\n    let [state] = useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n            case COMPONENT_UPDATE:\r\n                return {\r\n                    args,\r\n                    value:\r\n                        action.type === COMPONENT_CREATE\r\n                            ? callback()\r\n                            : isEqualArray(args, state.args)\r\n                            ? state.value\r\n                            : callback()\r\n                };\r\n        }\r\n        return state;\r\n    });\r\n    return state.value;\r\n}\r\n\r\nexport function useReducer(reducer, initialState) {\r\n    let next = getCurrentSnap().next,\r\n        type = \"useReducer/update\";\r\n    let [state, dispatch] = useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n                return initialState;\r\n            case type:\r\n                return reducer(state, action.use);\r\n        }\r\n        return state;\r\n    });\r\n    return [\r\n        state,\r\n        use => {\r\n            dispatch({ type, use });\r\n            next();\r\n        }\r\n    ];\r\n}\r\n","import { h, useEffect, useState } from \"../../../../src/index\";\r\n\r\nexport default function Dot({ s, y, x, size }) {\r\n    s = size * 1.3;\r\n    let [count, setCount] = useState(0);\r\n    let [hover, setHover] = useState();\r\n\r\n    useEffect(() => {\r\n        setInterval(() => {\r\n            count = count > 9 ? 0 : count;\r\n            setCount(++count);\r\n        }, 1000);\r\n    }, []);\r\n\r\n    return (\r\n        <div\r\n            style={`\r\n                position: absolute;\r\n                font: normal 15px sans-serif;\r\n                text-align: center;\r\n                cursor: pointer;\r\n                width: ${s}px;\r\n                height: ${s}px;\r\n                left: ${x}px;\r\n                top: ${y}px;\r\n                border-radius: ${s / 2}px;\r\n                line-height: ${s}px;\r\n                background: ${hover ? \"#ff0\" : \"#61dafb\"}\r\n            `}\r\n            onmouseenter={() => setHover(true)}\r\n            onmouseleave={() => setHover(false)}\r\n        >\r\n            {count}\r\n        </div>\r\n    );\r\n}\r\n","import { h, useMemo } from \"../../../../src/index\";\r\n\r\nimport Dot from \"./dot\";\r\nlet targetSize = 25;\r\n\r\nexport default function Triangle({ s, y, x }) {\r\n    if (s <= targetSize) {\r\n        return (\r\n            <Dot\r\n                x={x - targetSize / 2}\r\n                y={y - targetSize / 2}\r\n                size={targetSize}\r\n            />\r\n        );\r\n    }\r\n\r\n    s = s / 2;\r\n    return (\r\n        <div>\r\n            <Triangle x={x} y={y - s / 2} s={s} />\r\n            <Triangle x={x - s} y={y + s / 2} s={s} />\r\n            <Triangle x={x + s} y={y + s / 2} s={s} />\r\n        </div>\r\n    );\r\n}\r\n","import { h, render, useState, useEffect } from \"../../../../src/index\";\r\nimport Triange from \"./triangle\";\r\n\r\nfunction Run(props) {\r\n    let [time, setTime] = useState(0);\r\n    let t = (time / 1000) % 10;\r\n    let scale = 1 + (t > 5 ? 10 - t : t) / 10;\r\n\r\n    useEffect(() => {\r\n        let start = Date.now();\r\n        function update() {\r\n            setTime(Date.now() - start);\r\n            requestAnimationFrame(update);\r\n        }\r\n        let currentAnimation = requestAnimationFrame(update);\r\n        () => {\r\n            cancelAnimationFrame(currentAnimation);\r\n        };\r\n    }, []);\r\n\r\n    return (\r\n        <div\r\n            shadowDom\r\n            style={`\r\n                position:absolute;\r\n                transform-origin : 0 0;\r\n                left:50%;\r\n                top:50%;\r\n                width:10px;\r\n                height:10px;\r\n                background:#eee;\r\n                transform: scaleX( ${scale /\r\n                    2.1}) scaleY(0.7) translateZ(0.1px);\r\n            `}\r\n        >\r\n            <Triange x={0} y={0} s={1000} />\r\n        </div>\r\n    );\r\n}\r\n\r\nrender(<Run />, document.querySelector(\"#app\"));\r\n"],"names":["const","NODE_TEXT","NODE_HOST","TAG_VALUE","ATTRS_VALUE","SHADOWDOM","COMPONENT_CREATE","COMPONENT_UPDATE","COMPONENT_CREATED","COMPONENT_UPDATED","COMPONENT_REMOVE","EMPTY_CHILDREN","EVENT_ALIAS","options","maxConcurrentTask","isArray","value","Array","isEqualArray","before","after","let","length","i","h","tag","props","createVnode","children","defineVnode","type","nextProps","nextChildren","useKeys","useContext","useShadowDom","size","useChildren","mapChildren","deep","recicleChildren","child","undefined","key","Error","push","index","clearNode","ID","node","nodeList","childNodes","dispatch","CSS_PROPS","updateStyle","prevValue","nextValue","prevCss","nextCss","replace","all","letterBefore","letterAfter","toLowerCase","style","cssText","updateEvent","prevHandler","nextHandler","handlers","slice","toLocaleLowerCase","event","call","target","eventProxy","removeEventListener","addEventListener","IGNORE","removeAttribute","isSvg","CURRENT_SNAP","CURRENT_SNAP_KEY_HOOK","task","defer","Promise","resolve","currentTask","item","lvl","fun","arg","then","getCurrentSnap","useHook","reducer","hook","isCreate","component","hooks","dispatchHook","state","action","dispatchComponents","components","hooksLength","remove","createUpdateComponent","host","store","reduce","vnode","context","splice","updateNode","updateComponent","useNext","Object","prevent","next","setTask","vnextnode","nextHost","history","createNode","nextNode","doc","document","createElementNS","createElement","createTextNode","update","prevNode","currentUpdateComponent","vprevnode","nextTag","isFunction","nodeName","getNodeName","parent","parentNode","replaceChild","prevProps","currentProps","merge","typeNextValue","typePrevValue","shadowRoot","attachShadow","mode","setAttributeNS","setAttribute","current","updateProperties","vnextChildren","nodeKeys","nodeListLength","vnodeListLength","nodeListIndexStart","nodeChild","isRemove","dataset","removeChild","nextSibling","indexChild","prevChild","insertBefore","appendChild","updateChildren","nodeValue","useState","initialState","nextState","useEffect","callback","args","clear","Dot","ref","s","setInterval","count","setCount","x","y","hover","onmouseenter","setHover","onmouseleave","disableHost","customID","targetSize","Triangle","t","time","scale","start","Date","now","requestAnimationFrame","setTime","shadowDom","Triange","querySelector"],"mappings":"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"}