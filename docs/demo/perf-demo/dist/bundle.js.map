{"version":3,"file":"bundle.js","sources":["../../../../src/constants.js","../../../../src/options.js","../../../../src/utils.js","../../../../src/vnode.js","../../../../src/updateChildren.js","../../../../src/updateStyle.js","../../../../src/updateEvent.js","../../../../src/updateProperties.js","../../../../src/component.js","../../../../src/update.js","../../../../src/hooks.js","../src/dot.js","../src/triangle.js","../src/index.js"],"sourcesContent":["export const NODE_TEXT = \"#text\";\r\nexport const NODE_HOST = \"host\";\r\n\r\nexport const TAG_VALUE = \"@tag\";\r\n\r\nexport const CSS_VALUE = \"@css\";\r\n\r\nexport const ATTRS_VALUE = \"@attrs\";\r\n\r\nexport const SHADOWDOM = \"shadowDom\";\r\n\r\nexport const COMPONENT_CREATE = \"@create\";\r\nexport const COMPONENT_UPDATE = \"@update\";\r\nexport const COMPONENT_CREATED = \"@created\";\r\nexport const COMPONENT_UPDATED = \"@updated\";\r\nexport const COMPONENT_CLEAR = \"@clear\";\r\nexport const COMPONENT_REMOVE = \"@remove\";\r\n/**\r\n * if a list of children is empty in content it is\r\n * replaced by this constant with the intention\r\n * of simplifying the immutable comparison\r\n */\r\nexport const EMPTY_CHILDREN = [];\r\n/**\r\n * stores the transformations created in update Event,\r\n * by manipulating the name of the event\r\n */\r\nexport const EVENT_ALIAS = {};\r\n\r\nexport const CONTEXT = \"@ctx.\";\r\n","export let options = {\r\n    // defines the maximum amount of simultaneous tasks\r\n    maxConcurrentTask: 5000\r\n};\r\n","/**\r\n * Return if value is array\r\n * @param {*}\r\n * @return {boolean}\r\n */\r\nexport function isArray(value) {\r\n    return Array.isArray(value);\r\n}\r\n/**\r\n * compare 2 array\r\n * @param {array} before\r\n * @param {array} after\r\n * @example\r\n * isEqualArray([1,2,3,4],[1,2,3,4]) // true\r\n * isEqualArray([1,2,3,4],[1,2,3])   // false\r\n * isEqualArray([5,1,2,3],[1,2,3,5]) // false\r\n * isEqualArray([],[]) // true\r\n * @returns {boolean}\r\n */\r\nexport function isEqualArray(before, after) {\r\n    let length = before.length;\r\n    if (length !== after.length) return false;\r\n    for (let i = 0; i < length; i++) {\r\n        if (before[i] !== after[i]) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nexport function assign(master, commit) {\r\n    for (let key in commit) {\r\n        master[key] = commit[key];\r\n    }\r\n    for (let i = 2; i < arguments.length; i++) assign(master, arguments[i]);\r\n    return master;\r\n}\r\n\r\nlet defer = Promise.resolve(),\r\n    task = [];\r\nwindow._task = [];\r\nexport function setTask(handler, argument) {\r\n    if (!task.length) {\r\n        defer.then(() => {\r\n            let currentTask = task,\r\n                length = task.length;\r\n            task = [];\r\n            window._task.push(length);\r\n            for (let i = 0; i < length; i++) {\r\n                let value = currentTask[i];\r\n                value[0](value[1]);\r\n            }\r\n        });\r\n    }\r\n    task.push([handler, argument]);\r\n}\r\n","import { isArray } from \"./utils\";\r\nimport { EMPTY_CHILDREN, SHADOWDOM } from \"./constants\";\r\n/**\r\n * allows to transfer the arguments to createVnode\r\n * @param {string|function} tag - define the vnode to work\r\n * @param {object} [props] - vnode properties\r\n * @param {array} [children] - properties to be transmitted to the vnode\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return createVnode(tag, props, children);\r\n}\r\n/**\r\n * if the vnode is defined different from an object, it returns a vnode that creates a text node\r\n * @param {*} value\r\n * @return {object}\r\n */\r\nexport function defineVnode(value) {\r\n    let type = typeof value;\r\n    if (value && type === \"object\" && value.tag) {\r\n        return value;\r\n    } else {\r\n        return {\r\n            tag: \"#text\",\r\n            children: type === \"number\" || type === \"string\" ? \"\" + value : \"\"\r\n        };\r\n    }\r\n}\r\n/**\r\n * create a representative object of the node to be created, updated or deleted\r\n * @param {string|function} tag - type of node to represent\r\n * @param {object} nextProps - properties of the node to represent\r\n * @param {array} nextChildren - children of the node to represent\r\n */\r\nexport function createVnode(tag, nextProps, nextChildren) {\r\n    nextProps = nextProps || {};\r\n    // Increase the indexes to be reused.\r\n    let useKeys,\r\n        // key identifier\r\n        key,\r\n        // list of children\r\n        children,\r\n        // amount of props\r\n        size = 1,\r\n        // Tag properties\r\n        props = {},\r\n        // define whether the node will update the context\r\n        useContext,\r\n        // announces that the node will use shadowDom\r\n        useShadowDom,\r\n        // lets you ignore updateChildren\r\n        useChildren = true,\r\n        // scan the children recursively to form a list without depth\r\n        mapChildren = (nextChildren, deep = 0, children = []) => {\r\n            let length = nextChildren.length,\r\n                recicleChildren = true;\r\n            // allows recycling to nextChildren, if the condition is met\r\n            while (!deep && length === 1 && isArray(nextChildren[0])) {\r\n                nextChildren = nextChildren[0];\r\n                length = nextChildren.length;\r\n            }\r\n\r\n            if (!length) return EMPTY_CHILDREN;\r\n\r\n            for (let i = 0; i < length; i++) {\r\n                let child = nextChildren[i];\r\n                if (isArray(child)) {\r\n                    mapChildren(child, deep + 1, children);\r\n                    recicleChildren = false;\r\n                } else {\r\n                    let childType = typeof child;\r\n                    if (\r\n                        child &&\r\n                        childType === \"object\" &&\r\n                        child.key !== undefined\r\n                    ) {\r\n                        useKeys = useKeys || {};\r\n                        if (child.key in useKeys) {\r\n                            throw new Error(\r\n                                \"Each key must be unique among children\"\r\n                            );\r\n                        } else {\r\n                            useKeys[child.key] = true;\r\n                        }\r\n                    } else {\r\n                        if (useKeys) {\r\n                            throw new Error(\"Each child must have a key\");\r\n                        }\r\n                    }\r\n                    children.push(child);\r\n                }\r\n            }\r\n            return recicleChildren ? nextChildren : children;\r\n        };\r\n\r\n    for (let index in nextProps) {\r\n        let value = nextProps[index];\r\n        switch (index) {\r\n            case \"context\":\r\n                if (typeof value === \"object\") useContext = value;\r\n                continue;\r\n            case \"children\":\r\n                if (value === false) useChildren = false;\r\n                nextChildren = value;\r\n                continue;\r\n            case \"innerHTML\":\r\n            case \"textContent\":\r\n            case \"contenteditable\":\r\n                useChildren = false;\r\n                break;\r\n\r\n            case SHADOWDOM:\r\n                useShadowDom = value;\r\n                break;\r\n        }\r\n        props[index] = value;\r\n        size++;\r\n    }\r\n\r\n    // children is empty, it is replaced by the constant, in order to compare the empty state\r\n    props.children = children = mapChildren(nextChildren);\r\n\r\n    return {\r\n        tag,\r\n        key,\r\n        size,\r\n        props,\r\n        children,\r\n        useKeys,\r\n        useContext,\r\n        useChildren,\r\n        useShadowDom\r\n    };\r\n}\r\n","import { update, createNode } from \"./update\";\r\nimport { defineVnode } from \"./vnode\";\r\nimport { NODE_TEXT, COMPONENT_REMOVE, COMPONENT_CLEAR } from \"./constants\";\r\n/**\r\n * issue elimination to the entire tree of nodes\r\n * @param {string} ID\r\n * @param {HTMLElement|SVGElement|Text} node\r\n */\r\nexport function clearNode(ID, node, clear, currentUpdateComponent) {\r\n    let { updateComponent } = node[ID] || {},\r\n        nodeList = node.childNodes,\r\n        length = nodeList.length;\r\n    if (updateComponent && updateComponent !== currentUpdateComponent) {\r\n        updateComponent(clear ? COMPONENT_CLEAR : COMPONENT_REMOVE);\r\n    }\r\n    for (let i = 0; i < length; i++) {\r\n        clearNode(ID, nodeList[i]);\r\n    }\r\n}\r\n/**\r\n *\r\n * @param {string} ID\r\n * @param {HTMLElement|SVGElement|Text} node - node to extract current children\r\n * @param {object} vnextChildren  - list of children to update\r\n * @param {object|undefined} useKeys - index of keys to keep in the next update\r\n * @param {boolean} isSvg - define if it is a svg tree\r\n * @param {object} context - current context to share\r\n * @return {HTMLElement|SVGElement|Text}\r\n */\r\nexport function updateChildren(\r\n    ID,\r\n    node,\r\n    vnextChildren,\r\n    useKeys,\r\n    isSvg,\r\n    context\r\n) {\r\n    let nodeKeys = {},\r\n        nodeList = node.childNodes,\r\n        nodeListLength = nodeList.length,\r\n        vnodeListLength = vnextChildren.length,\r\n        /**\r\n         * modifies the start of the iteration based on the type whether it is using keys or indexes\r\n         * this is done for a deletion without iterate completely nodeList\r\n         */\r\n        nodeListIndexStart = useKeys\r\n            ? 0\r\n            : nodeListLength > vnodeListLength\r\n            ? vnodeListLength\r\n            : nodeListLength;\r\n    for (; nodeListIndexStart < nodeListLength; nodeListIndexStart++) {\r\n        let nodeChild = nodeList[nodeListIndexStart],\r\n            isRemove,\r\n            key = nodeListIndexStart;\r\n        // if the iteration uses keys, the node is stored in the index corresponding to its key\r\n        if (useKeys) {\r\n            key = nodeChild.dataset.key;\r\n            if (key in useKeys) {\r\n                nodeKeys[key] = nodeChild;\r\n            } else {\r\n                isRemove = true;\r\n            }\r\n        } else {\r\n            isRemove = true;\r\n        }\r\n        if (nodeChild && isRemove) {\r\n            clearNode(ID, nodeChild);\r\n            nodeListLength--;\r\n            nodeListIndexStart--;\r\n            node.removeChild(nodeChild);\r\n        }\r\n    }\r\n    for (let i = 0; i < vnodeListLength; i++) {\r\n        let vnode = defineVnode(vnextChildren[i]),\r\n            nextSibling = nodeList[i + 1],\r\n            useKey = useKeys ? vnode.key : i,\r\n            indexChild = nodeList[i],\r\n            prevChild = useKeys ? nodeKeys[vnode.key] : indexChild;\r\n\r\n        if (useKeys) {\r\n            if (prevChild !== indexChild) {\r\n                node.insertBefore(prevChild, indexChild);\r\n            }\r\n        }\r\n\r\n        // if it is a component and it does not have an associative node, it will create one to work within update\r\n        if (typeof vnode.tag === \"function\") {\r\n            if (!prevChild) {\r\n                prevChild = createNode(NODE_TEXT);\r\n                if (nextSibling) {\r\n                    node.insertBefore(prevChild, nextSibling);\r\n                } else {\r\n                    node.appendChild(prevChild);\r\n                }\r\n            }\r\n        }\r\n\r\n        let nextNode = update(ID, prevChild, vnode, isSvg, context);\r\n\r\n        if (!prevChild) {\r\n            if (nextSibling) {\r\n                node.insertBefore(nextNode, nextSibling);\r\n            } else {\r\n                node.appendChild(nextNode);\r\n            }\r\n        }\r\n    }\r\n}\r\n","/**\r\n * memorizes the transformations associated with the css properties.\r\n * @example\r\n * {borderRadius:\"50px\"} // {\"border-radius\" : \"50px\"}\r\n */\r\nconst CSS_PROPS = {};\r\n\r\n/**\r\n * Define the style property immutably\r\n * @param {HTMLElement|SVGAElement} node\r\n * @param {object|string} nextValue\r\n */\r\nexport function updateStyle(node, prevValue, nextValue) {\r\n    // this function has the previous state of the css directly from the node by the constant [CSS_VALUE]\r\n    let prevCss = prevValue,\r\n        nextCss = nextValue;\r\n    if (typeof nextValue === \"object\") {\r\n        nextCss = \"\";\r\n        for (let key in nextValue) {\r\n            if (!nextValue[key]) continue;\r\n            if (!CSS_PROPS[key]) {\r\n                CSS_PROPS[key] = key.replace(\r\n                    /([^A-Z])([A-Z])/g,\r\n                    (all, letterBefore, letterAfter) =>\r\n                        letterBefore + \"-\" + letterAfter.toLowerCase()\r\n                );\r\n            }\r\n            nextCss += `${CSS_PROPS[key]}:${nextValue[key]};`;\r\n        }\r\n    }\r\n\r\n    if (prevCss !== nextCss) {\r\n        node.style.cssText = nextCss;\r\n    }\r\n\r\n    return nextCss;\r\n}\r\n","import { options } from \"./options\";\r\nimport { EVENT_ALIAS } from \"./constants\";\r\n\r\nexport function updateEvent(node, type, prevHandler, nextHandler, handlers) {\r\n    if (!EVENT_ALIAS[type])\r\n        EVENT_ALIAS[type] = type.slice(2).toLocaleLowerCase();\r\n\r\n    type = EVENT_ALIAS[type];\r\n    if (!handlers[type]) {\r\n        handlers[type] = [event => handlers[type][1].call(event.target, event)];\r\n    }\r\n    let eventProxy = handlers[type][0];\r\n    if (prevHandler && !nextHandler) {\r\n        node.removeEventListener(type, eventProxy);\r\n        delete handlers[type];\r\n    } else {\r\n        if (!prevHandler && nextHandler) {\r\n            node.addEventListener(type, eventProxy);\r\n        }\r\n        handlers[type][1] = nextHandler;\r\n    }\r\n}\r\n","import { updateStyle } from \"./updateStyle\";\r\nimport { updateEvent } from \"./updateEvent\";\r\nimport { ATTRS_VALUE, SHADOWDOM } from \"./constants\";\r\n// properties to ignore by updateProperties\r\nconst IGNORE = {\r\n    children: 1\r\n};\r\n\r\nfunction removeAttribute(node, isSvg, key) {\r\n    node.removeAttribute(isSvg && key === \"xlink\" ? \"xlink:href\" : key);\r\n}\r\n\r\n/**\r\n * define the properties of the node\r\n * @param {HTMLElement|SVGAElement} node\r\n * @param {object} nextProps\r\n * @param {boolean} isSvg\r\n */\r\nexport function updateProperties(node, prevProps, nextProps, handlers, isSvg) {\r\n    prevProps = prevProps || {};\r\n    let attrsValues = node[ATTRS_VALUE] || {};\r\n    for (let key in prevProps) {\r\n        if (IGNORE[key]) continue;\r\n        if (key in nextProps) {\r\n            if (!(key in nextProps) && key in attrsValues) {\r\n                setProperty(node, key, \"\", null, attrsValues, handlers, isSvg);\r\n            }\r\n        }\r\n    }\r\n    for (let key in nextProps) {\r\n        if (IGNORE[key]) continue;\r\n        setProperty(\r\n            node,\r\n            key,\r\n            prevProps[key],\r\n            nextProps[key],\r\n            attrsValues,\r\n            handlers,\r\n            isSvg\r\n        );\r\n    }\r\n    node[ATTRS_VALUE] = attrsValues;\r\n}\r\nfunction setProperty(\r\n    node,\r\n    key,\r\n    prevValue,\r\n    nextValue,\r\n    attrsValues,\r\n    handlers,\r\n    isSvg\r\n) {\r\n    let merge = true;\r\n\r\n    prevValue =\r\n        key in handlers\r\n            ? handlers[key]\r\n            : prevValue === null\r\n            ? prevValue\r\n            : attrsValues[key];\r\n\r\n    if (nextValue === prevValue) return;\r\n    if (\r\n        key[0] === \"o\" &&\r\n        key[1] === \"n\" &&\r\n        (typeof nextValue === \"function\" || typeof prevValue === \"function\")\r\n    ) {\r\n        updateEvent(node, key, prevValue, nextValue, handlers);\r\n        return;\r\n    }\r\n\r\n    switch (key) {\r\n        case \"ref\":\r\n            if (nextValue) nextValue.current = node;\r\n            break;\r\n        case \"style\":\r\n            nextValue = updateStyle(\r\n                node,\r\n                prevValue || node.style.cssText,\r\n                nextValue\r\n            );\r\n            break;\r\n        case SHADOWDOM:\r\n            if (\"attachShadow\" in node) {\r\n                if (\r\n                    (node.shadowRoot && !nextValue) ||\r\n                    (!node.shadowRoot && nextValue)\r\n                ) {\r\n                    node.attachShadow({ mode: nextValue ? \"open\" : \"closed\" });\r\n                }\r\n            }\r\n            return;\r\n\r\n        case \"key\":\r\n            key = \"data-key\";\r\n            if (nextValue === null) {\r\n                delete node.dataset.key;\r\n            } else {\r\n                node.dataset.key = nextValue;\r\n            }\r\n            break;\r\n        case \"class\":\r\n        case \"className\":\r\n            key = isSvg ? \"class\" : \"className\";\r\n        default:\r\n            if (key !== \"list\" && !isSvg && key in node) {\r\n                node[key] = nextValue === null ? \"\" : nextValue;\r\n            } else if (nextValue === null) {\r\n                node.removeAttribute(key);\r\n            } else {\r\n                node.setAttribute(key, nextValue);\r\n            }\r\n    }\r\n\r\n    attrsValues[key] = nextValue;\r\n}\r\n","import { setTask, assign } from \"./utils\";\r\nimport {\r\n    COMPONENT_CREATE,\r\n    COMPONENT_UPDATE,\r\n    COMPONENT_CREATED,\r\n    COMPONENT_UPDATED,\r\n    COMPONENT_REMOVE,\r\n    COMPONENT_CLEAR\r\n} from \"./constants\";\r\n\r\nimport { update as updateNode } from \"./update\";\r\n\r\nlet CURRENT_SNAP, CURRENT_SNAP_KEY_HOOK;\r\n\r\nexport function getCurrentSnap() {\r\n    if (!CURRENT_SNAP) {\r\n        throw new Error(\r\n            \"the hooks can only be called from an existing functional component in the diff queue\"\r\n        );\r\n    }\r\n    return CURRENT_SNAP;\r\n}\r\n\r\nexport function useHook(reducer, state) {\r\n    let component = getCurrentSnap().component,\r\n        index = CURRENT_SNAP_KEY_HOOK++,\r\n        hook,\r\n        isCreate;\r\n    if (!component.hooks[index]) {\r\n        isCreate = true;\r\n        component.hooks[index] = { state };\r\n    }\r\n    hook = component.hooks[index];\r\n    hook.reducer = reducer;\r\n    if (isCreate) dispatchHook(hook, { type: COMPONENT_CREATE });\r\n    return [hook.state, action => dispatchHook(hook, action)];\r\n}\r\n\r\nexport function dispatchHook(hook, action) {\r\n    if (hook.reducer) {\r\n        hook.state = hook.reducer(hook.state, action);\r\n    }\r\n}\r\n\r\nexport function dispatchComponents(components, action) {\r\n    let length = components.length;\r\n    for (let i = 0; i < length; i++) {\r\n        let component = components[i],\r\n            hooks = component.hooks,\r\n            hooksLength = hooks.length;\r\n        if (action.type === COMPONENT_REMOVE) {\r\n            component.remove = true;\r\n        }\r\n        for (let i = 0; i < hooksLength; i++) {\r\n            dispatchHook(hooks[i], action);\r\n        }\r\n    }\r\n}\r\n/**\r\n * this function allows creating a block that analyzes the tag\r\n * defined as a function, in turn creates a global update scope for hook management.\r\n */\r\nexport function createUpdateComponent(ID, isSvg) {\r\n    let prevent,\r\n        store = [],\r\n        host;\r\n    /**\r\n     * This function allows reducing the functional components based on\r\n     * their return, in turn creates a unique state for each component\r\n     * according to a depth index\r\n     * @param {function} vnode\r\n     * @param {object} context\r\n     * @param {number} deep\r\n     */\r\n    function reduce(vnode, context, deep) {\r\n        // if host does not exist as a node, the vnode is not reduced\r\n        if (!host) return;\r\n        vnode = vnode || \"\";\r\n        // if it is different from a functional node, it is sent to updateNode again\r\n        if (typeof vnode.tag !== \"function\") {\r\n            dispatchComponents(store.splice(deep), {\r\n                type: COMPONENT_REMOVE\r\n            });\r\n            host = updateNode(ID, host, vnode, isSvg, context, updateComponent);\r\n            // if the store no longer has a length, it is assumed that the updateComponent is no longer necessary\r\n            if (store.length) host[ID].updateComponent = updateComponent;\r\n\r\n            return;\r\n        }\r\n        // you get the current component\r\n        let component = store[deep] || {},\r\n            isCreate,\r\n            useNext;\r\n        // if the current component is dis- torted to the analyzed one,\r\n        // the previous state is replaced with a new one and the elimination is dispatched.\r\n        if (component.tag !== vnode.tag) {\r\n            isCreate = true;\r\n            // the state of the component is defined\r\n            store[deep] = {\r\n                size: 1,\r\n                tag: vnode.tag,\r\n                hooks: [],\r\n                props: {},\r\n                context: {}\r\n            };\r\n            // the elimination is sent to the successors of the previous component\r\n            dispatchComponents(store.splice(deep + 1), {\r\n                type: COMPONENT_REMOVE\r\n            });\r\n            useNext = true;\r\n        }\r\n\r\n        component = store[deep];\r\n        // then a series of simple processes are carried out capable of\r\n        // identifying if the component requires an update\r\n\r\n        context = vnode.useContext\r\n            ? assign({}, context, vnode.useContext)\r\n            : context;\r\n\r\n        if (component.context !== context) {\r\n            // the current context is stored in the cache\r\n            component.context = context;\r\n            // create a new context\r\n\r\n            useNext = true;\r\n        }\r\n\r\n        if (!useNext) {\r\n            // compare the lake of properties\r\n            if (vnode.size !== component.size) useNext = true;\r\n            if (!useNext) {\r\n                // buy property by property, so the properties to be used\r\n                // in the areas must be immutable\r\n                for (let key in vnode.props) {\r\n                    if (vnode.props[key] !== component.props[key]) {\r\n                        useNext = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        component.props = vnode.props;\r\n        component.size = vnode.size;\r\n        /**\r\n         * this function is a snapshot of the current component,\r\n         * allows to run the component and launch the next update\r\n         */\r\n        function next() {\r\n            if (component.remove) return host;\r\n\r\n            CURRENT_SNAP = {\r\n                component,\r\n                context,\r\n                // allows access to the instantaneous, but it uses the microtareas\r\n                // to prevent multiple synchronous updates\r\n                next() {\r\n                    if (!component.prevent) {\r\n                        component.prevent = true;\r\n                        setTask(() => {\r\n                            component.prevent = false;\r\n                            next();\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n\r\n            CURRENT_SNAP_KEY_HOOK = 0;\r\n\r\n            dispatchComponents([component], { type: COMPONENT_UPDATE });\r\n\r\n            let vnextnode = component.tag(component.props, context);\r\n\r\n            CURRENT_SNAP = false;\r\n            CURRENT_SNAP_KEY_HOOK = 0;\r\n\r\n            reduce(vnextnode, context, deep + 1);\r\n\r\n            dispatchComponents([component], {\r\n                type: isCreate ? COMPONENT_CREATED : COMPONENT_UPDATED\r\n            });\r\n\r\n            isCreate = false;\r\n        }\r\n\r\n        if (useNext && !component.prevent) next();\r\n    }\r\n    /**\r\n     *\r\n     * @param {string} type\r\n     * @param {HTMLElement|SVGElement|Text} nextHost\r\n     * @param {object} vnode\r\n     * @param {object} context\r\n     */\r\n    function updateComponent(type, nextHost, vnode, context) {\r\n        switch (type) {\r\n            case COMPONENT_UPDATE:\r\n                host = nextHost;\r\n                reduce(vnode, context, 0);\r\n                return host;\r\n            case COMPONENT_CLEAR:\r\n                dispatchComponents([].concat(store).reverse(), { type });\r\n                break;\r\n            case COMPONENT_REMOVE:\r\n                host = false;\r\n                dispatchComponents(store.reverse(), { type });\r\n                store = [];\r\n                break;\r\n        }\r\n    }\r\n\r\n    return updateComponent;\r\n}\r\n","import { NODE_TEXT, NODE_HOST, TAG_VALUE, COMPONENT_UPDATE } from \"./constants\";\r\nimport { options } from \"./options\";\r\nimport { defineVnode } from \"./vnode\";\r\nimport { updateChildren, clearNode } from \"./updateChildren\";\r\nimport { updateProperties } from \"./updateProperties\";\r\nimport { createUpdateComponent } from \"./component\";\r\nimport { createVnode } from \"./vnode\";\r\n/**\r\n * @param {object} vnode\r\n * @param {HTMLElement|SVGElement} node\r\n * @param {string} [customID]\r\n * @param {boolean} disableHost\r\n */\r\nexport function render(vnode, node, disableHost, customID = \"@vn\") {\r\n    if (!disableHost) {\r\n        vnode = defineVnode(vnode);\r\n        if (vnode.tag !== NODE_HOST) {\r\n            vnode = createVnode(NODE_HOST, {}, [vnode]);\r\n        }\r\n    }\r\n    update(customID, node, vnode);\r\n}\r\n\r\nexport function createNode(tag, isSvg) {\r\n    let doc = options.document || document,\r\n        nextNode;\r\n    if (tag !== NODE_TEXT) {\r\n        nextNode = isSvg\r\n            ? doc.createElementNS(\"http://www.w3.org/2000/svg\", tag)\r\n            : doc.createElement(tag);\r\n    } else {\r\n        nextNode = doc.createTextNode(\"\");\r\n    }\r\n    nextNode[TAG_VALUE] = tag;\r\n    return nextNode;\r\n}\r\n\r\nexport function getNodeName(node) {\r\n    if (!node) return;\r\n    // store the process locally in the node to avoid transformation\r\n    if (!node[TAG_VALUE]) {\r\n        node[TAG_VALUE] = node.nodeName.toLowerCase();\r\n    }\r\n    return node[TAG_VALUE];\r\n}\r\n/**\r\n *\r\n * @param {string} ID - store the process locally in the node to avoid transformation\r\n * @param {HTMLElement|SVGElement|Text|undefined} prevNode - if the current node is defined and the next\r\n * one to be used is different, the replacement of the current node will be made\r\n * @param {*} vnode\r\n * @param {boolean} isSvg\r\n * @param {object} context\r\n * @param {function|undefined} currentUpdateComponent\r\n */\r\nexport function update(\r\n    ID,\r\n    prevNode,\r\n    vnode,\r\n    isSvg,\r\n    context,\r\n    currentUpdateComponent\r\n) {\r\n    // get a node object\r\n    vnode = defineVnode(vnode);\r\n    // if the previous state exists, it obtains the state\r\n    let { vnode: vprevnode = {}, handlers = {}, updateComponent } =\r\n        (prevNode && prevNode[ID]) || {};\r\n    // if the node stored in the previous state is identical to the current one,\r\n    // it will not execute the update process\r\n    if (vnode === vprevnode) return prevNode;\r\n\r\n    let {\r\n        // defines the next node to manipulate the concurrent tree\r\n        tag: nextTag,\r\n        // define the properties that the next node must possess\r\n        props: nextProps,\r\n        // define the children that this node must possess in the following state\r\n        children: nextChildren,\r\n        // transmits keys to the updateChildren that is kept in the children list\r\n        useKeys,\r\n        // define if they would use updateChildren\r\n        useChildren,\r\n        // define if shadowDom was used\r\n        useShadowDom\r\n    } = vnode;\r\n    // define if the tree is of the SVG type\r\n    isSvg = isSvg || nextTag === \"svg\";\r\n\r\n    let nextNode = prevNode,\r\n        isFunction = typeof nextTag === \"function\";\r\n\r\n    // create an updateComponent\r\n    if (isFunction && !updateComponent) {\r\n        updateComponent = createUpdateComponent(ID, isSvg);\r\n    }\r\n\r\n    if (\r\n        getNodeName(prevNode) !== nextTag &&\r\n        nextTag !== \"host\" &&\r\n        !isFunction\r\n    ) {\r\n        nextNode = createNode(nextTag, isSvg);\r\n        handlers = {};\r\n        let parent = prevNode && prevNode.parentNode;\r\n        if (parent) {\r\n            clearNode(ID, prevNode, true, currentUpdateComponent);\r\n            parent.replaceChild(nextNode, prevNode);\r\n        }\r\n    }\r\n    if (updateComponent && currentUpdateComponent !== updateComponent) {\r\n        return updateComponent(COMPONENT_UPDATE, nextNode, vnode, context);\r\n    } else if (nextTag !== NODE_TEXT) {\r\n        updateProperties(nextNode, vprevnode.props, nextProps, handlers, isSvg);\r\n        if (useChildren && vprevnode.children !== vnode.children) {\r\n            updateChildren(\r\n                ID,\r\n                useShadowDom ? nextNode.shadowRoot || nextNode : nextNode,\r\n                nextChildren,\r\n                useKeys,\r\n                isSvg,\r\n                context\r\n            );\r\n        }\r\n    } else {\r\n        if (nextNode.nodeValue !== nextChildren) {\r\n            nextNode.nodeValue = nextChildren;\r\n        }\r\n    }\r\n\r\n    nextNode[ID] = { handlers, vnode, updateComponent };\r\n\r\n    return nextNode;\r\n}\r\n","import { getCurrentSnap, useHook } from \"./component\";\r\n\r\nimport { isEqualArray, assign } from \"./utils\";\r\n\r\nimport {\r\n    COMPONENT_CREATE,\r\n    COMPONENT_CREATED,\r\n    COMPONENT_UPDATE,\r\n    COMPONENT_UPDATED,\r\n    COMPONENT_REMOVE,\r\n    COMPONENT_CLEAR\r\n} from \"./constants\";\r\n\r\nexport function useState(initialState) {\r\n    let next = getCurrentSnap().next,\r\n        type = \"useState/update\";\r\n    let [state, dispatch] = useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n                return typeof initialState === \"function\"\r\n                    ? initialState()\r\n                    : initialState;\r\n            case type:\r\n                let nextState = action.state;\r\n                return typeof nextState === \"function\"\r\n                    ? nextState(state)\r\n                    : nextState;\r\n        }\r\n        return state;\r\n    });\r\n    return [\r\n        state,\r\n        state => {\r\n            dispatch({ state, type });\r\n            next();\r\n        }\r\n    ];\r\n}\r\n\r\nexport function useEffect(callback, args) {\r\n    useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n                return { args };\r\n            case COMPONENT_UPDATE:\r\n            case COMPONENT_REMOVE:\r\n                if (state.clear) {\r\n                    let next =\r\n                        action.type === COMPONENT_REMOVE ||\r\n                        (args && state.args\r\n                            ? !isEqualArray(args, state.args)\r\n                            : true);\r\n                    if (next) state.clear();\r\n                }\r\n                return assign({}, state, { args });\r\n            case COMPONENT_CREATED:\r\n            case COMPONENT_UPDATED:\r\n                let next =\r\n                        action.type === COMPONENT_CREATED ||\r\n                        (args && state.args\r\n                            ? !isEqualArray(args, state.args)\r\n                            : true),\r\n                    clear = state.clear;\r\n                if (next) {\r\n                    clear = callback();\r\n                }\r\n                return assign({}, state, { clear, args });\r\n        }\r\n        return state;\r\n    });\r\n}\r\n\r\nexport function useRef(current) {\r\n    let [state] = useHook(false, {});\r\n    return state;\r\n}\r\n\r\nexport function useMemo(callback, args) {\r\n    let [state] = useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n            case COMPONENT_UPDATE:\r\n                return {\r\n                    args,\r\n                    value:\r\n                        action.type === COMPONENT_CREATE\r\n                            ? callback()\r\n                            : isEqualArray(args, state.args)\r\n                            ? state.value\r\n                            : callback()\r\n                };\r\n        }\r\n        return state;\r\n    });\r\n    return state.value;\r\n}\r\n\r\nexport function useReducer(reducer, initialState) {\r\n    let next = getCurrentSnap().next,\r\n        type = \"useReducer/update\";\r\n    let [state, dispatch] = useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n                return initialState;\r\n            case type:\r\n                return reducer(state, action.use);\r\n        }\r\n        return state;\r\n    });\r\n    return [\r\n        state,\r\n        use => {\r\n            dispatch({ type, use });\r\n            next();\r\n        }\r\n    ];\r\n}\r\n","import { h, useEffect, useState } from \"../../../../src/index\";\r\n\r\nexport default function Dot({ s, y, x, size }) {\r\n    s = size * 1.3;\r\n    let [count, setCount] = useState(0);\r\n    let [hover, setHover] = useState();\r\n\r\n    useEffect(() => {\r\n        setInterval(() => {\r\n            count = count > 9 ? 0 : count;\r\n            setCount(++count);\r\n        }, 1000);\r\n    }, []);\r\n\r\n    return (\r\n        <div\r\n            style={`\r\n                position: absolute;\r\n                font: normal 15px sans-serif;\r\n                text-align: center;\r\n                cursor: pointer;\r\n                width: ${s}px;\r\n                height: ${s}px;\r\n                left: ${x}px;\r\n                top: ${y}px;\r\n                border-radius: ${s / 2}px;\r\n                line-height: ${s}px;\r\n                background: ${hover ? \"#ff0\" : \"#61dafb\"}\r\n            `}\r\n            onmouseenter={() => setHover(true)}\r\n            onmouseleave={() => setHover(false)}\r\n        >\r\n            {count}\r\n        </div>\r\n    );\r\n}\r\n","import { h, useMemo } from \"../../../../src/index\";\r\n\r\nimport Dot from \"./dot\";\r\nlet targetSize = 25;\r\n\r\nexport default function Triangle({ s, y, x }) {\r\n    if (s <= targetSize) {\r\n        return (\r\n            <Dot\r\n                x={x - targetSize / 2}\r\n                y={y - targetSize / 2}\r\n                size={targetSize}\r\n            />\r\n        );\r\n    }\r\n\r\n    s = s / 2;\r\n    return (\r\n        <div>\r\n            <Triangle x={x} y={y - s / 2} s={s} />\r\n            <Triangle x={x - s} y={y + s / 2} s={s} />\r\n            <Triangle x={x + s} y={y + s / 2} s={s} />\r\n        </div>\r\n    );\r\n}\r\n","import { h, render, useState, useEffect } from \"../../../../src/index\";\r\nimport Triange from \"./triangle\";\r\n\r\nfunction Run(props) {\r\n    let [time, setTime] = useState(0);\r\n    let t = (time / 1000) % 10;\r\n    let scale = 1 + (t > 5 ? 10 - t : t) / 10;\r\n\r\n    useEffect(() => {\r\n        let start = Date.now();\r\n        function update() {\r\n            setTime(Date.now() - start);\r\n            requestAnimationFrame(update);\r\n        }\r\n        let currentAnimation = requestAnimationFrame(update);\r\n        () => {\r\n            cancelAnimationFrame(currentAnimation);\r\n        };\r\n    }, []);\r\n\r\n    return (\r\n        <div\r\n            shadowDom\r\n            style={`\r\n                position:absolute;\r\n                transform-origin : 0 0;\r\n                left:50%;\r\n                top:50%;\r\n                width:10px;\r\n                height:10px;\r\n                background:#eee;\r\n                transform: scaleX( ${scale /\r\n                    2.1}) scaleY(0.7) translateZ(0.1px);\r\n            `}\r\n        >\r\n            <Triange x={0} y={0} s={1000} />\r\n        </div>\r\n    );\r\n}\r\n\r\nrender(<Run />, document.querySelector(\"#app\"));\r\n"],"names":["const","let","arguments","key","i","updateNode","next","Triange"],"mappings":"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"}