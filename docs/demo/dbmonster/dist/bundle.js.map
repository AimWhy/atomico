{"version":3,"file":"bundle.js","sources":["../../../../src/constants.js","../../../../src/options.js","../../../../src/utils.js","../../../../src/vnode.js","../../../../src/updateChildren.js","../../../../src/updateStyle.js","../../../../src/updateEvent.js","../../../../src/updateProperties.js","../../../../src/task.js","../../../../src/component.js","../../../../src/update.js","../../../../src/hooks.js","../src/index.js"],"sourcesContent":["export const NODE_TEXT = \"#text\";\r\nexport const NODE_HOST = \"host\";\r\n\r\nexport const TAG_VALUE = \"@tag\";\r\n\r\nexport const CSS_VALUE = \"@css\";\r\n\r\nexport const ATTRS_VALUE = \"@attrs\";\r\n\r\nexport const SHADOWDOM = \"shadowDom\";\r\n\r\nexport const COMPONENT_CREATE = \"@create\";\r\nexport const COMPONENT_UPDATE = \"@update\";\r\nexport const COMPONENT_CREATED = \"@created\";\r\nexport const COMPONENT_UPDATED = \"@updated\";\r\nexport const COMPONENT_CLEAR = \"@clear\";\r\nexport const COMPONENT_REMOVE = \"@remove\";\r\n/**\r\n * if a list of children is empty in content it is\r\n * replaced by this constant with the intention\r\n * of simplifying the immutable comparison\r\n */\r\nexport const EMPTY_CHILDREN = [];\r\n/**\r\n * stores the transformations created in update Event,\r\n * by manipulating the name of the event\r\n */\r\nexport const EVENT_ALIAS = {};\r\n\r\nexport const CONTEXT = \"@ctx.\";\r\n","export let options = {\r\n    // defines the maximum amount of simultaneous tasks\r\n    maxConcurrentTask: 5000\r\n};\r\n","/**\r\n * Return if value is array\r\n * @param {*}\r\n * @return {boolean}\r\n */\r\nexport function isArray(value) {\r\n    return Array.isArray(value);\r\n}\r\n/**\r\n * compare 2 array\r\n * @param {array} before\r\n * @param {array} after\r\n * @example\r\n * isEqualArray([1,2,3,4],[1,2,3,4]) // true\r\n * isEqualArray([1,2,3,4],[1,2,3])   // false\r\n * isEqualArray([5,1,2,3],[1,2,3,5]) // false\r\n * isEqualArray([],[]) // true\r\n * @returns {boolean}\r\n */\r\nexport function isEqualArray(before, after) {\r\n    let length = before.length;\r\n    if (length !== after.length) return false;\r\n    for (let i = 0; i < length; i++) {\r\n        if (before[i] !== after[i]) return false;\r\n    }\r\n    return true;\r\n}\r\n","import { isArray } from \"./utils\";\r\nimport { EMPTY_CHILDREN, SHADOWDOM } from \"./constants\";\r\n/**\r\n * allows to transfer the arguments to createVnode\r\n * @param {string|function} tag - define the vnode to work\r\n * @param {object} [props] - vnode properties\r\n * @param {array} [children] - properties to be transmitted to the vnode\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return createVnode(tag, props, children);\r\n}\r\n/**\r\n * if the vnode is defined different from an object, it returns a vnode that creates a text node\r\n * @param {*} value\r\n * @return {object}\r\n */\r\nexport function defineVnode(value) {\r\n    let type = typeof value;\r\n    if (value && type === \"object\" && value.tag) {\r\n        return value;\r\n    } else {\r\n        return {\r\n            tag: \"#text\",\r\n            children: type === \"number\" || type === \"string\" ? \"\" + value : \"\"\r\n        };\r\n    }\r\n}\r\n/**\r\n * create a representative object of the node to be created, updated or deleted\r\n * @param {string|function} tag - type of node to represent\r\n * @param {object} nextProps - properties of the node to represent\r\n * @param {array} nextChildren - children of the node to represent\r\n */\r\nexport function createVnode(tag, nextProps, nextChildren) {\r\n    nextProps = nextProps || {};\r\n    // Increase the indexes to be reused.\r\n    let useKeys,\r\n        // key identifier\r\n        key,\r\n        // list of children\r\n        children,\r\n        // amount of props\r\n        size = 1,\r\n        // Tag properties\r\n        props = {},\r\n        // define whether the node will update the context\r\n        useContext,\r\n        // announces that the node will use shadowDom\r\n        useShadowDom,\r\n        // lets you ignore updateChildren\r\n        useChildren = true,\r\n        // scan the children recursively to form a list without depth\r\n        mapChildren = (nextChildren, deep = 0, children = []) => {\r\n            let length = nextChildren.length,\r\n                recicleChildren = true;\r\n            // allows recycling to nextChildren, if the condition is met\r\n            while (!deep && length === 1 && isArray(nextChildren[0])) {\r\n                nextChildren = nextChildren[0];\r\n                length = nextChildren.length;\r\n            }\r\n\r\n            if (!length) return EMPTY_CHILDREN;\r\n\r\n            for (let i = 0; i < length; i++) {\r\n                let child = nextChildren[i];\r\n                if (isArray(child)) {\r\n                    mapChildren(child, deep + 1, children);\r\n                    recicleChildren = false;\r\n                } else {\r\n                    let childType = typeof child;\r\n                    if (\r\n                        child &&\r\n                        childType === \"object\" &&\r\n                        child.key !== undefined\r\n                    ) {\r\n                        useKeys = useKeys || {};\r\n                        if (child.key in useKeys) {\r\n                            throw new Error(\r\n                                \"Each key must be unique among children\"\r\n                            );\r\n                        } else {\r\n                            useKeys[child.key] = true;\r\n                        }\r\n                    } else {\r\n                        if (useKeys) {\r\n                            throw new Error(\"Each child must have a key\");\r\n                        }\r\n                    }\r\n                    children.push(child);\r\n                }\r\n            }\r\n            return recicleChildren ? nextChildren : children;\r\n        };\r\n\r\n    for (let index in nextProps) {\r\n        let value = nextProps[index];\r\n        switch (index) {\r\n            case \"context\":\r\n                if (typeof value === \"object\") useContext = value;\r\n                continue;\r\n            case \"children\":\r\n                if (value === false) useChildren = false;\r\n                nextChildren = value;\r\n                continue;\r\n            case \"innerHTML\":\r\n            case \"textContent\":\r\n            case \"contenteditable\":\r\n                useChildren = false;\r\n                break;\r\n            case \"class\":\r\n                index = \"className\";\r\n                break;\r\n            case SHADOWDOM:\r\n                useShadowDom = value;\r\n                break;\r\n            case \"key\":\r\n                index = \"data-key\";\r\n                break;\r\n        }\r\n        props[index] = value;\r\n        size++;\r\n    }\r\n\r\n    // children is empty, it is replaced by the constant, in order to compare the empty state\r\n    props.children = children = mapChildren(nextChildren);\r\n\r\n    return {\r\n        tag,\r\n        key,\r\n        size,\r\n        props,\r\n        children,\r\n        useKeys,\r\n        useContext,\r\n        useChildren,\r\n        useShadowDom\r\n    };\r\n}\r\n","import { update, createNode } from \"./update\";\r\nimport { defineVnode } from \"./vnode\";\r\nimport { NODE_TEXT, COMPONENT_REMOVE } from \"./constants\";\r\n/**\r\n * issue elimination to the entire tree of nodes\r\n * @param {string} ID\r\n * @param {HTMLElement|SVGElement|Text} node\r\n */\r\nexport function clearNode(ID, node) {\r\n    let { dispatch } = node[ID] || {},\r\n        nodeList = node.childNodes,\r\n        length = nodeList.length;\r\n    if (dispatch) dispatch(COMPONENT_REMOVE);\r\n    for (let i = 0; i < length; i++) {\r\n        clearNode(ID, nodeList[i]);\r\n    }\r\n}\r\n/**\r\n *\r\n * @param {string} ID\r\n * @param {HTMLElement|SVGElement|Text} node - node to extract current children\r\n * @param {object} vnextChildren  - list of children to update\r\n * @param {object|undefined} useKeys - index of keys to keep in the next update\r\n * @param {boolean} isSvg - define if it is a svg tree\r\n * @param {object} context - current context to share\r\n * @return {HTMLElement|SVGElement|Text}\r\n */\r\nexport function updateChildren(\r\n    ID,\r\n    node,\r\n    vnextChildren,\r\n    useKeys,\r\n    isSvg,\r\n    context\r\n) {\r\n    let nodeKeys = {},\r\n        nodeList = node.childNodes,\r\n        nodeListLength = nodeList.length,\r\n        vnodeListLength = vnextChildren.length,\r\n        /**\r\n         * modifies the start of the iteration based on the type whether it is using keys or indexes\r\n         * this is done for a deletion without iterate completely nodeList\r\n         */\r\n        nodeListIndexStart = useKeys\r\n            ? 0\r\n            : nodeListLength > vnodeListLength\r\n            ? vnodeListLength\r\n            : nodeListLength;\r\n    for (; nodeListIndexStart < nodeListLength; nodeListIndexStart++) {\r\n        let nodeChild = nodeList[nodeListIndexStart],\r\n            isRemove,\r\n            key = nodeListIndexStart;\r\n        // if the iteration uses keys, the node is stored in the index corresponding to its key\r\n        if (useKeys) {\r\n            key = nodeChild.dataset.key;\r\n            if (key in useKeys) {\r\n                nodeKeys[key] = nodeChild;\r\n            } else {\r\n                isRemove = true;\r\n            }\r\n        } else {\r\n            isRemove = true;\r\n        }\r\n        if (nodeChild && isRemove) {\r\n            clearNode(ID, nodeChild);\r\n            nodeListLength--;\r\n            nodeListIndexStart--;\r\n            node.removeChild(nodeChild);\r\n        }\r\n    }\r\n    for (let i = 0; i < vnodeListLength; i++) {\r\n        let vnode = defineVnode(vnextChildren[i]),\r\n            nextSibling = nodeList[i + 1],\r\n            useKey = useKeys ? vnode.key : i,\r\n            indexChild = nodeList[i],\r\n            prevChild = useKeys ? nodeKeys[vnode.key] : indexChild;\r\n\r\n        if (useKeys) {\r\n            if (prevChild !== indexChild) {\r\n                node.insertBefore(prevChild, indexChild);\r\n            }\r\n        }\r\n\r\n        // if it is a component and it does not have an associative node, it will create one to work within update\r\n        if (typeof vnode.tag === \"function\") {\r\n            if (!prevChild) {\r\n                prevChild = createNode(NODE_TEXT);\r\n                if (nextSibling) {\r\n                    node.insertBefore(prevChild, nextSibling);\r\n                } else {\r\n                    node.appendChild(prevChild);\r\n                }\r\n            }\r\n        }\r\n\r\n        let nextNode = update(ID, prevChild, vnode, isSvg, context);\r\n\r\n        if (!prevChild) {\r\n            if (nextSibling) {\r\n                node.insertBefore(nextNode, nextSibling);\r\n            } else {\r\n                node.appendChild(nextNode);\r\n            }\r\n        }\r\n    }\r\n}\r\n","/**\r\n * memorizes the transformations associated with the css properties.\r\n * @example\r\n * {borderRadius:\"50px\"} // {\"border-radius\" : \"50px\"}\r\n */\r\nconst CSS_PROPS = {};\r\n\r\n/**\r\n * Define the style property immutably\r\n * @param {HTMLElement|SVGAElement} node\r\n * @param {object|string} nextValue\r\n */\r\nexport function updateStyle(node, prevValue, nextValue) {\r\n    // this function has the previous state of the css directly from the node by the constant [CSS_VALUE]\r\n    let prevCss = prevValue,\r\n        nextCss = nextValue;\r\n    if (typeof nextValue === \"object\") {\r\n        nextCss = \"\";\r\n        for (let key in nextValue) {\r\n            if (!nextValue[key]) continue;\r\n            if (!CSS_PROPS[key]) {\r\n                CSS_PROPS[key] = key.replace(\r\n                    /([^A-Z])([A-Z])/g,\r\n                    (all, letterBefore, letterAfter) =>\r\n                        letterBefore + \"-\" + letterAfter.toLowerCase()\r\n                );\r\n            }\r\n            nextCss += `${CSS_PROPS[key]}:${nextValue[key]};`;\r\n        }\r\n    }\r\n\r\n    if (prevCss !== nextCss) {\r\n        node.style.cssText = nextCss;\r\n    }\r\n\r\n    return nextCss;\r\n}\r\n","import { options } from \"./options\";\r\nimport { EVENT_ALIAS } from \"./constants\";\r\n\r\nexport function updateEvent(node, type, prevHandler, nextHandler, handlers) {\r\n    if (type[0] !== \"o\" && type[1] !== \"n\") return;\r\n\r\n    if (!EVENT_ALIAS[type])\r\n        EVENT_ALIAS[type] = type.slice(2).toLocaleLowerCase();\r\n\r\n    type = EVENT_ALIAS[type];\r\n    if (!handlers[type]) {\r\n        handlers[type] = [event => handlers[type][1].call(event.target, event)];\r\n    }\r\n    let eventProxy = handlers[type][0];\r\n    if (prevHandler && !nextHandler) {\r\n        node.removeEventListener(type, eventProxy);\r\n        delete handlers[type];\r\n    } else {\r\n        if (!prevHandler && nextHandler) {\r\n            node.addEventListener(type, eventProxy);\r\n        }\r\n        handlers[type][1] = nextHandler;\r\n    }\r\n}\r\n","import { updateStyle } from \"./updateStyle\";\r\nimport { updateEvent } from \"./updateEvent\";\r\nimport { ATTRS_VALUE, SHADOWDOM } from \"./constants\";\r\n// properties to ignore by updateProperties\r\nconst IGNORE = {\r\n    children: 1\r\n};\r\n\r\nfunction removeAttribute(node, isSvg, key) {\r\n    node.removeAttribute(isSvg && key === \"xlink\" ? \"xlink:href\" : key);\r\n}\r\n/**\r\n * define the properties of the node\r\n * @param {HTMLElement|SVGAElement} node\r\n * @param {object} nextProps\r\n * @param {boolean} isSvg\r\n */\r\nexport function updateProperties(node, prevProps, nextProps, handlers, isSvg) {\r\n    prevProps = prevProps || {};\r\n    // currentProps, allows to isolate the manipulated properties,\r\n    // to sustain a process of parallel states without conflict\r\n    let currentProps = node[ATTRS_VALUE] || {};\r\n    for (let key in prevProps) {\r\n        // IGNORE allows you to ignore a property.\r\n        if (IGNORE[key]) continue;\r\n        // If the property does not exist in the following definition, it is eliminated\r\n        if (!(key in nextProps) && key in currentProps) {\r\n            if (key in node) {\r\n                node[key] = null;\r\n            } else {\r\n                removeAttribute(node, isSvg, key);\r\n            }\r\n            delete currentProps[key];\r\n        }\r\n    }\r\n    for (let key in nextProps) {\r\n        // IGNORE allows you to ignore a property.\r\n        if (IGNORE[key]) continue;\r\n\r\n        let merge = true;\r\n\r\n        let nextValue = nextProps[key],\r\n            typeNextValue = typeof nextValue;\r\n        // get the previous value either from handlers or currentProps\r\n        let prevValue = key in handlers ? handlers[key] : currentProps[key],\r\n            typePrevValue = typeof prevValue;\r\n        // define undefined as value for empty comparison\r\n        nextValue =\r\n            nextValue === null || nextValue === undefined\r\n                ? undefined\r\n                : nextValue;\r\n\r\n        if (nextValue === prevValue) continue;\r\n\r\n        // updates the state of the ref object\r\n        if (key === \"ref\") {\r\n            if (nextValue) nextValue.current = node;\r\n            continue;\r\n        }\r\n\r\n        // Enables the use of shadowDom over the node\r\n        if (SHADOWDOM === key && \"attachShadow\" in node) {\r\n            if (\r\n                (node.shadowRoot && !nextValue) ||\r\n                (!node.shadowRoot && nextValue)\r\n            ) {\r\n                node.attachShadow({ mode: nextValue ? \"open\" : \"closed\" });\r\n            }\r\n            continue;\r\n        }\r\n\r\n        if (typeNextValue === \"function\" || typePrevValue === \"function\") {\r\n            updateEvent(node, key, prevValue, nextValue, handlers);\r\n            merge = false;\r\n        } else if (\r\n            nextValue !== undefined &&\r\n            ((key in node && !isSvg) || (isSvg && key === \"style\"))\r\n        ) {\r\n            if (key === \"style\") {\r\n                nextValue = updateStyle(\r\n                    node,\r\n                    prevValue || node.style.cssText,\r\n                    nextValue\r\n                );\r\n            } else {\r\n                node[key] = nextValue;\r\n            }\r\n        } else if (nextValue) {\r\n            isSvg\r\n                ? node.setAttributeNS(\r\n                      isSvg && key === \"xlink\"\r\n                          ? \"http://www.w3.org/1999/xlink\"\r\n                          : null,\r\n                      key === \"xlink\" ? \"xlink:href\" : key,\r\n                      nextValue\r\n                  )\r\n                : node.setAttribute(key, nextValue);\r\n        } else {\r\n            // proceeds to remove the node attribute and remove the currentProps registry\r\n            removeAttribute(node, isSvg, key);\r\n            delete currentProps[key];\r\n            merge = false;\r\n        }\r\n        if (merge) {\r\n            currentProps[key] = nextValue;\r\n        }\r\n    }\r\n    node[ATTRS_VALUE] = currentProps;\r\n}\r\n","import { options } from \"./options\";\r\nlet task = [],\r\n    defer = Promise.resolve();\r\n/**\r\n * allows to solve the pending tasks\r\n */\r\nfunction resolve() {\r\n    let currentTask = task,\r\n        length = currentTask.length;\r\n\r\n    task = [];\r\n\r\n    for (let i = 0; i < length; i++) {\r\n        let item = currentTask[i];\r\n        // discounts a level to the pending task, if it reaches 0 it is executed\r\n        if (--item.lvl) {\r\n            item.fun(item.arg);\r\n        } else {\r\n            // if the number of queued tasks is greater than\r\n            // options.maxConcurrentTask, the subsequent queue will be left\r\n            if (task.length > options.maxConcurrentTask) item.lvl++;\r\n            // Rescue the task to add it to the next queue\r\n            task.push(item);\r\n        }\r\n    }\r\n    // If there are remaining tasks, generate another cycle to clean the tasks\r\n    if (task.length) defer.then(resolve); //;setTimeout(() => defer.then(resolve));\r\n}\r\n/**\r\n * add a task to the waiting list\r\n * @param {function} fun - function to execute once the task has been solved.\r\n * @param {*} [arg] - argument to deliver to the task, once it is resolved\r\n * @param {number} [lvl] - level of importance 1 is important 2 is less important and so on\r\n */\r\nexport function setTask(fun, arg, lvl = 1) {\r\n    let length = task.length;\r\n    //if (length > options.maxConcurrentTask) lvl++;\r\n    task.push({ fun, arg, lvl });\r\n    // a cycle is created only if there is not one running\r\n    if (!length) {\r\n        defer.then(resolve);\r\n    }\r\n}\r\n","import { setTask } from \"./task\";\r\nimport {\r\n    COMPONENT_CREATE,\r\n    COMPONENT_UPDATE,\r\n    COMPONENT_CREATED,\r\n    COMPONENT_UPDATED,\r\n    COMPONENT_REMOVE\r\n} from \"./constants\";\r\n\r\nimport { update as updateNode } from \"./update\";\r\n\r\nlet CURRENT_SNAP, CURRENT_SNAP_KEY_HOOK;\r\n\r\nexport function getCurrentSnap() {\r\n    if (!CURRENT_SNAP) {\r\n        throw new Error(\r\n            \"the hooks can only be called from an existing functional component in the diff queue\"\r\n        );\r\n    }\r\n    return CURRENT_SNAP;\r\n}\r\n\r\nexport function useHook(reducer) {\r\n    let component = getCurrentSnap().component,\r\n        index = CURRENT_SNAP_KEY_HOOK++,\r\n        hook,\r\n        isCreate;\r\n    if (!component.hooks[index]) {\r\n        isCreate = true;\r\n        component.hooks[index] = {};\r\n    }\r\n    hook = component.hooks[index];\r\n    hook.reducer = reducer;\r\n    if (isCreate) dispatchHook(hook, { type: COMPONENT_CREATE });\r\n    return [hook.state, action => dispatchHook(hook, action)];\r\n}\r\n\r\nexport function dispatchHook(hook, action) {\r\n    hook.state = hook.reducer(hook.state, action);\r\n}\r\n\r\nexport function dispatchComponents(components, action) {\r\n    let length = components.length;\r\n    for (let i = 0; i < length; i++) {\r\n        let component = components[i],\r\n            hooks = component.hooks,\r\n            hooksLength = hooks.length;\r\n        if (action.type === COMPONENT_REMOVE) {\r\n            component.remove = true;\r\n        }\r\n        for (let i = 0; i < hooksLength; i++) {\r\n            dispatchHook(hooks[i], action);\r\n        }\r\n    }\r\n}\r\n/**\r\n * this function allows creating a block that analyzes the tag\r\n * defined as a function, in turn creates a global update scope for hook management.\r\n */\r\nexport function createUpdateComponent(ID, isSvg) {\r\n    let prevent,\r\n        store = [],\r\n        host;\r\n    /**\r\n     * This function allows reducing the functional components based on\r\n     * their return, in turn creates a unique state for each component\r\n     * according to a depth index\r\n     * @param {function} vnode\r\n     * @param {object} context\r\n     * @param {number} deep\r\n     */\r\n    function reduce(vnode, context, deep) {\r\n        // if host does not exist as a node, the vnode is not reduced\r\n        if (!host) return;\r\n        vnode = vnode || \"\";\r\n        // if it is different from a functional node, it is sent to updateNode again\r\n        if (typeof vnode.tag !== \"function\") {\r\n            dispatchComponents(store.splice(deep), {\r\n                type: COMPONENT_REMOVE\r\n            });\r\n            host = updateNode(ID, host, vnode, isSvg, context, updateComponent);\r\n            // if the store no longer has a length, it is assumed that the updateComponent is no longer necessary\r\n            if (store.length) host[ID].updateComponent = updateComponent;\r\n\r\n            return;\r\n        }\r\n        // you get the current component\r\n        let component = store[deep] || {},\r\n            isCreate,\r\n            useNext;\r\n        // if the current component is dis- torted to the analyzed one,\r\n        // the previous state is replaced with a new one and the elimination is dispatched.\r\n        if (component.tag !== vnode.tag) {\r\n            isCreate = true;\r\n            // the state of the component is defined\r\n            store[deep] = {\r\n                lvl: 1,\r\n                size: 1,\r\n                tag: vnode.tag,\r\n                hooks: [],\r\n                props: {},\r\n                context: {}\r\n            };\r\n            // the elimination is sent to the successors of the previous component\r\n            dispatchComponents(store.splice(deep + 1), {\r\n                type: COMPONENT_REMOVE\r\n            });\r\n            useNext = true;\r\n        }\r\n\r\n        component = store[deep];\r\n        // then a series of simple processes are carried out capable of\r\n        // identifying if the component requires an update\r\n        if (component.context !== vnode.useContext) {\r\n            // the current context is stored in the cache\r\n            component.context = vnode.useContext;\r\n            // create a new context\r\n            context = { ...context, ...vnode.useContext };\r\n            useNext = true;\r\n        }\r\n\r\n        if (!useNext) {\r\n            // compare the lake of properties\r\n            if (vnode.size !== component.size) useNext = true;\r\n            if (!useNext) {\r\n                // buy property by property, so the properties to be used\r\n                // in the areas must be immutable\r\n                for (let key in vnode.props) {\r\n                    if (vnode.props[key] !== component.props[key]) {\r\n                        useNext = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        component.props = vnode.props;\r\n        component.size = vnode.size;\r\n        /**\r\n         * this function is a snapshot of the current component,\r\n         * allows to run the component and launch the next update\r\n         */\r\n        function next() {\r\n            if (component.remove) return host;\r\n\r\n            CURRENT_SNAP = {\r\n                component,\r\n                context,\r\n                // allows access to the instantaneous, but it uses the microtareas\r\n                // to prevent multiple synchronous updates\r\n                next() {\r\n                    if (!component.prevent) {\r\n                        component.prevent = true;\r\n                        setTask(() => {\r\n                            component.prevent = false;\r\n                            next();\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n\r\n            CURRENT_SNAP_KEY_HOOK = 0;\r\n\r\n            dispatchComponents([component], { type: COMPONENT_UPDATE });\r\n\r\n            let vnextnode = component.tag(component.props, context);\r\n\r\n            CURRENT_SNAP = false;\r\n            CURRENT_SNAP_KEY_HOOK = 0;\r\n\r\n            reduce(vnextnode, context, deep + 1);\r\n\r\n            dispatchComponents([component], {\r\n                type: isCreate ? COMPONENT_CREATED : COMPONENT_UPDATED\r\n            });\r\n\r\n            isCreate = false;\r\n        }\r\n\r\n        if (useNext && !component.prevent) next();\r\n    }\r\n    /**\r\n     *\r\n     * @param {string} type\r\n     * @param {HTMLElement|SVGElement|Text} nextHost\r\n     * @param {object} vnode\r\n     * @param {object} context\r\n     */\r\n    function updateComponent(type, nextHost, vnode, context) {\r\n        switch (type) {\r\n            case COMPONENT_UPDATE:\r\n                host = nextHost;\r\n                reduce(vnode, context, 0);\r\n                return host;\r\n            case COMPONENT_REMOVE:\r\n                host = false;\r\n                dispatchComponents(history, { type });\r\n                history = [];\r\n                break;\r\n        }\r\n    }\r\n\r\n    return updateComponent;\r\n}\r\n","import { NODE_TEXT, NODE_HOST, TAG_VALUE, COMPONENT_UPDATE } from \"./constants\";\r\nimport { options } from \"./options\";\r\nimport { defineVnode } from \"./vnode\";\r\nimport { updateChildren } from \"./updateChildren\";\r\nimport { updateProperties } from \"./updateProperties\";\r\nimport { createUpdateComponent } from \"./component\";\r\nimport { setTask } from \"./task\";\r\nimport { createVnode } from \"./vnode\";\r\n/**\r\n * @param {object} vnode\r\n * @param {HTMLElement|SVGElement} node\r\n * @param {string} [customID]\r\n * @param {boolean} disableHost\r\n */\r\nexport function render(vnode, node, disableHost, customID = \"@vn\") {\r\n    if (!disableHost) {\r\n        vnode = defineVnode(vnode);\r\n        if (vnode.tag !== NODE_HOST) {\r\n            vnode = createVnode(NODE_HOST, {}, [vnode]);\r\n        }\r\n    }\r\n    update(customID, node, vnode);\r\n}\r\n\r\nexport function createNode(tag, isSvg) {\r\n    let doc = options.document || document,\r\n        nextNode;\r\n    if (tag !== NODE_TEXT) {\r\n        nextNode = isSvg\r\n            ? doc.createElementNS(\"http://www.w3.org/2000/svg\", tag)\r\n            : doc.createElement(tag);\r\n    } else {\r\n        nextNode = doc.createTextNode(\"\");\r\n    }\r\n    nextNode[TAG_VALUE] = tag;\r\n    return nextNode;\r\n}\r\n\r\nexport function getNodeName(node) {\r\n    if (!node) return;\r\n    // store the process locally in the node to avoid transformation\r\n    if (!node[TAG_VALUE]) {\r\n        node[TAG_VALUE] = node.nodeName.toLowerCase();\r\n    }\r\n    return node[TAG_VALUE];\r\n}\r\n/**\r\n *\r\n * @param {string} ID - store the process locally in the node to avoid transformation\r\n * @param {HTMLElement|SVGElement|Text|undefined} prevNode - if the current node is defined and the next\r\n * one to be used is different, the replacement of the current node will be made\r\n * @param {*} vnode\r\n * @param {boolean} isSvg\r\n * @param {object} context\r\n * @param {function|undefined} currentUpdateComponent\r\n */\r\nexport function update(\r\n    ID,\r\n    prevNode,\r\n    vnode,\r\n    isSvg,\r\n    context,\r\n    currentUpdateComponent\r\n) {\r\n    // get a node object\r\n    vnode = defineVnode(vnode);\r\n    // if the previous state exists, it obtains the state\r\n    let { vnode: vprevnode = {}, handlers = {}, updateComponent } =\r\n        (prevNode && prevNode[ID]) || {};\r\n    // if the node stored in the previous state is identical to the current one,\r\n    // it will not execute the update process\r\n    if (vnode === vprevnode) return prevNode;\r\n\r\n    let {\r\n        // defines the next node to manipulate the concurrent tree\r\n        tag: nextTag,\r\n        // define the properties that the next node must possess\r\n        props: nextProps,\r\n        // define the children that this node must possess in the following state\r\n        children: nextChildren,\r\n        // transmits keys to the updateChildren that is kept in the children list\r\n        useKeys,\r\n        // define if they would use updateChildren\r\n        useChildren,\r\n        // define if shadowDom was used\r\n        useShadowDom\r\n    } = vnode;\r\n    // define if the tree is of the SVG type\r\n    isSvg = isSvg || nextTag === \"svg\";\r\n\r\n    let nextNode = prevNode,\r\n        isFunction = typeof nextTag === \"function\";\r\n\r\n    // create an updateComponent\r\n    if (isFunction && !updateComponent) {\r\n        updateComponent = createUpdateComponent(ID, isSvg);\r\n    }\r\n\r\n    if (\r\n        getNodeName(prevNode) !== nextTag &&\r\n        nextTag !== \"host\" &&\r\n        !isFunction\r\n    ) {\r\n        nextNode = createNode(nextTag, isSvg);\r\n        handlers = {};\r\n        let parent = prevNode && prevNode.parentNode;\r\n        if (parent) parent.replaceChild(nextNode, prevNode);\r\n    }\r\n    if (updateComponent && currentUpdateComponent !== updateComponent) {\r\n        return updateComponent(COMPONENT_UPDATE, nextNode, vnode, context);\r\n    } else if (nextTag !== NODE_TEXT) {\r\n        updateProperties(nextNode, vprevnode.props, nextProps, handlers, isSvg);\r\n        if (useChildren && vprevnode.children !== vnode.children) {\r\n            updateChildren(\r\n                ID,\r\n                useShadowDom ? nextNode.shadowRoot || nextNode : nextNode,\r\n                nextChildren,\r\n                useKeys,\r\n                isSvg,\r\n                context\r\n            );\r\n        }\r\n    } else {\r\n        if (nextNode.nodeValue !== nextChildren) {\r\n            nextNode.nodeValue = nextChildren;\r\n        }\r\n    }\r\n\r\n    nextNode[ID] = { handlers, vnode, updateComponent };\r\n\r\n    return nextNode;\r\n}\r\n","import { getCurrentSnap, useHook } from \"./component\";\r\n\r\nimport { isEqualArray } from \"./utils\";\r\n\r\nimport {\r\n    COMPONENT_CREATE,\r\n    COMPONENT_CREATED,\r\n    COMPONENT_UPDATE,\r\n    COMPONENT_UPDATED,\r\n    COMPONENT_REMOVE,\r\n    COMPONENT_CLEAR\r\n} from \"./constants\";\r\n\r\nexport function useState(initialState) {\r\n    let next = getCurrentSnap().next,\r\n        type = \"useState/update\";\r\n    let [state, dispatch] = useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n                return typeof initialState === \"function\"\r\n                    ? initialState()\r\n                    : initialState;\r\n            case type:\r\n                let nextState = action.state;\r\n                return typeof nextState === \"function\"\r\n                    ? nextState(state)\r\n                    : nextState;\r\n        }\r\n        return state;\r\n    });\r\n    return [\r\n        state,\r\n        state => {\r\n            dispatch({ state, type });\r\n            next();\r\n        }\r\n    ];\r\n}\r\n\r\nexport function useEffect(callback, args) {\r\n    useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n                return { args };\r\n            case COMPONENT_UPDATE:\r\n            case COMPONENT_REMOVE:\r\n                if (state.clear) {\r\n                    let next =\r\n                        action.type === COMPONENT_REMOVE ||\r\n                        (args && state.args\r\n                            ? !isEqualArray(args, state.args)\r\n                            : true);\r\n                    if (next) state.clear();\r\n                }\r\n                return { ...state, args };\r\n            case COMPONENT_CREATED:\r\n            case COMPONENT_UPDATED:\r\n                let next =\r\n                        action.type === COMPONENT_CREATED ||\r\n                        (args && state.args\r\n                            ? !isEqualArray(args, state.args)\r\n                            : true),\r\n                    clear = state.clear;\r\n                if (next) {\r\n                    clear = callback();\r\n                }\r\n                return { ...state, clear, args };\r\n        }\r\n        return state;\r\n    });\r\n}\r\n\r\nexport function useRef(current) {\r\n    let [state] = useHook((state = {}, action) =>\r\n        action.type === COMPONENT_CREATE ? { current } : state\r\n    );\r\n    return state;\r\n}\r\n\r\nexport function useMemo(callback, args) {\r\n    let [state] = useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n            case COMPONENT_UPDATE:\r\n                return {\r\n                    args,\r\n                    value:\r\n                        action.type === COMPONENT_CREATE\r\n                            ? callback()\r\n                            : isEqualArray(args, state.args)\r\n                            ? state.value\r\n                            : callback()\r\n                };\r\n        }\r\n        return state;\r\n    });\r\n    return state.value;\r\n}\r\n\r\nexport function useReducer(reducer, initialState) {\r\n    let next = getCurrentSnap().next,\r\n        type = \"useReducer/update\";\r\n    let [state, dispatch] = useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n                return initialState;\r\n            case type:\r\n                return reducer(state, action.use);\r\n        }\r\n        return state;\r\n    });\r\n    return [\r\n        state,\r\n        use => {\r\n            dispatch({ type, use });\r\n            next();\r\n        }\r\n    ];\r\n}\r\n","import { h, render, useEffect, useState } from \"../../../../src/index\";\r\n\r\nfunction Table(props) {\r\n    return (\r\n        <table class=\"table table-striped latest-data\">\r\n            <tbody>\r\n                {props.dbs.map(data => (\r\n                    <tr>\r\n                        <td class=\"dbname\">{data.dbname}</td>\r\n\r\n                        <td class=\"query-count\">\r\n                            <span class={data.lastSample.countClassName}>\r\n                                {data.lastSample.nbQueries}\r\n                            </span>\r\n                        </td>\r\n                        {data.lastSample.topFiveQueries.map(data => (\r\n                            <td class={\"Query \" + data.elapsedClassName}>\r\n                                {data.formatElapsed}\r\n                                <div class=\"popover left\">\r\n                                    <div class=\"popover-content\">\r\n                                        {data.query}\r\n                                    </div>\r\n                                    <div class=\"arrow\" />\r\n                                </div>\r\n                            </td>\r\n                        ))}\r\n                    </tr>\r\n                ))}\r\n            </tbody>\r\n        </table>\r\n    );\r\n}\r\n\r\nperfMonitor.startFPSMonitor();\r\nperfMonitor.startMemMonitor();\r\nperfMonitor.initProfiler(\"view update\");\r\n\r\nfunction getData() {\r\n    return ENV.generateData().toArray();\r\n}\r\n\r\nfunction Rerender() {\r\n    perfMonitor.startProfile(\"view update\");\r\n    let [state, setState] = useState(getData);\r\n    useEffect(() => {\r\n        function loop() {\r\n            setState(getData());\r\n            setTimeout(loop, ENV.timeout);\r\n        }\r\n        loop();\r\n    }, []);\r\n    useEffect(() => {\r\n        perfMonitor.endProfile(\"view update\");\r\n    });\r\n    return <Table dbs={state} />;\r\n}\r\n\r\nrender(<Rerender />, document.getElementById(\"body\"));\r\n"],"names":["const","NODE_TEXT","NODE_HOST","TAG_VALUE","ATTRS_VALUE","SHADOWDOM","COMPONENT_CREATE","COMPONENT_UPDATE","COMPONENT_CREATED","COMPONENT_UPDATED","COMPONENT_REMOVE","EMPTY_CHILDREN","EVENT_ALIAS","options","maxConcurrentTask","isArray","value","Array","isEqualArray","before","after","let","length","i","h","tag","props","createVnode","children","defineVnode","type","nextProps","nextChildren","useKeys","useContext","useShadowDom","size","useChildren","mapChildren","deep","recicleChildren","child","undefined","key","Error","push","index","clearNode","ID","node","nodeList","childNodes","dispatch","CSS_PROPS","updateStyle","prevValue","nextValue","prevCss","nextCss","replace","all","letterBefore","letterAfter","toLowerCase","style","cssText","updateEvent","prevHandler","nextHandler","handlers","slice","toLocaleLowerCase","event","call","target","eventProxy","removeEventListener","addEventListener","IGNORE","removeAttribute","isSvg","CURRENT_SNAP","CURRENT_SNAP_KEY_HOOK","vnode","disableHost","customID","task","defer","Promise","resolve","currentTask","item","lvl","fun","arg","then","getCurrentSnap","useHook","reducer","hook","isCreate","component","hooks","dispatchHook","state","action","dispatchComponents","components","hooksLength","remove","createUpdateComponent","host","store","reduce","context","splice","updateNode","updateComponent","useNext","Object","prevent","next","setTask","vnextnode","nextHost","history","createNode","nextNode","doc","document","createElementNS","createElement","createTextNode","update","prevNode","currentUpdateComponent","vprevnode","nextTag","isFunction","nodeName","getNodeName","parent","parentNode","replaceChild","prevProps","currentProps","merge","typeNextValue","typePrevValue","shadowRoot","attachShadow","mode","setAttributeNS","setAttribute","current","updateProperties","vnextChildren","nodeKeys","nodeListLength","vnodeListLength","nodeListIndexStart","nodeChild","isRemove","dataset","removeChild","nextSibling","indexChild","prevChild","insertBefore","appendChild","updateChildren","nodeValue","useEffect","callback","args","clear","Table","class","dbs","map","data","dbname","lastSample","countClassName","nbQueries","topFiveQueries","elapsedClassName","formatElapsed","query","getData","ENV","generateData","toArray","perfMonitor","startFPSMonitor","startMemMonitor","initProfiler","startProfile","initialState","nextState","useState","loop","setState","setTimeout","timeout","endProfile","getElementById"],"mappings":"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"}