{"version":3,"file":"bundle.iife.js","sources":["../../../src/constants.js","../../../src/options.js","../../../src/utils.js","../../../src/vnode.js","../../../src/updateChildren.js","../../../src/updateStyle.js","../../../src/updateEvent.js","../../../src/updateProperties.js","../../../src/task.js","../../../src/component.js","../../../src/update.js","../../../src/hooks.js","../src/index.js"],"sourcesContent":["export const NODE_TEXT = \"#text\";\r\nexport const NODE_HOST = \"host\";\r\n\r\nexport const TAG_VALUE = \"@tag\";\r\n\r\nexport const CSS_VALUE = \"@css\";\r\n\r\nexport const ATTRS_VALUE = \"@attrs\";\r\n\r\nexport const SHADOWDOM = \"shadowDom\";\r\n\r\nexport const COMPONENT_CREATE = \"@create\";\r\nexport const COMPONENT_UPDATE = \"@update\";\r\nexport const COMPONENT_CREATED = \"@created\";\r\nexport const COMPONENT_UPDATED = \"@updated\";\r\nexport const COMPONENT_CLEAR = \"@clear\";\r\nexport const COMPONENT_REMOVE = \"@remove\";\r\n/**\r\n * if a list of children is empty in content it is\r\n * replaced by this constant with the intention\r\n * of simplifying the immutable comparison\r\n */\r\nexport const EMPTY_CHILDREN = [];\r\n/**\r\n * stores the transformations created in update Event,\r\n * by manipulating the name of the event\r\n */\r\nexport const EVENT_ALIAS = {};\r\n\r\nexport const CONTEXT = \"@ctx.\";\r\n","export let options = {\r\n    // defines the maximum amount of simultaneous tasks\r\n    maxConcurrentTask: 5000\r\n};\r\n","/**\r\n * Return if value is array\r\n * @param {*}\r\n * @return {boolean}\r\n */\r\nexport function isArray(value) {\r\n    return Array.isArray(value);\r\n}\r\n/**\r\n * compare 2 array\r\n * @param {array} before\r\n * @param {array} after\r\n * @example\r\n * isEqualArray([1,2,3,4],[1,2,3,4]) // true\r\n * isEqualArray([1,2,3,4],[1,2,3])   // false\r\n * isEqualArray([5,1,2,3],[1,2,3,5]) // false\r\n * isEqualArray([],[]) // true\r\n * @returns {boolean}\r\n */\r\nexport function isEqualArray(before, after) {\r\n    let length = before.length;\r\n    if (length !== after.length) return false;\r\n    for (let i = 0; i < length; i++) {\r\n        if (before[i] !== after[i]) return false;\r\n    }\r\n    return true;\r\n}\r\n","import { isArray } from \"./utils\";\r\nimport { EMPTY_CHILDREN, SHADOWDOM } from \"./constants\";\r\n/**\r\n * allows to transfer the arguments to createVnode\r\n * @param {string|function} tag - define the vnode to work\r\n * @param {object} [props] - vnode properties\r\n * @param {array} [children] - properties to be transmitted to the vnode\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return createVnode(tag, props, children);\r\n}\r\n/**\r\n * if the vnode is defined different from an object, it returns a vnode that creates a text node\r\n * @param {*} value\r\n * @return {object}\r\n */\r\nexport function defineVnode(value) {\r\n    let type = typeof value;\r\n    if (type === \"object\" && value.tag) {\r\n        return value;\r\n    } else {\r\n        return {\r\n            tag: \"#text\",\r\n            children: type === \"number\" || type === \"string\" ? \"\" + value : \"\"\r\n        };\r\n    }\r\n}\r\n/**\r\n * create a representative object of the node to be created, updated or deleted\r\n * @param {string|function} tag - type of node to represent\r\n * @param {object} nextProps - properties of the node to represent\r\n * @param {array} nextChildren - children of the node to represent\r\n */\r\nexport function createVnode(tag, nextProps, nextChildren) {\r\n    nextProps = nextProps || {};\r\n    // Increase the indexes to be reused.\r\n    let useKeys,\r\n        // key identifier\r\n        key,\r\n        // list of children\r\n        children,\r\n        // amount of props\r\n        size = 1,\r\n        // Tag properties\r\n        props = {},\r\n        // define whether the node will update the context\r\n        useContext,\r\n        // announces that the node will use shadowDom\r\n        useShadowDom,\r\n        // lets you ignore updateChildren\r\n        useChildren = true,\r\n        // scan the children recursively to form a list without depth\r\n        mapChildren = (nextChildren, deep = 0, children = []) => {\r\n            let length = nextChildren.length,\r\n                recicleChildren = true;\r\n            // allows recycling to nextChildren, if the condition is met\r\n            while (!deep && length === 1 && isArray(nextChildren[0])) {\r\n                nextChildren = nextChildren[0];\r\n                length = nextChildren.length;\r\n            }\r\n\r\n            for (let i = 0; i < length; i++) {\r\n                let child = nextChildren[i];\r\n                if (isArray(child)) {\r\n                    mapChildren(child, deep + 1, children);\r\n                    recicleChildren = false;\r\n                } else {\r\n                    let childType = typeof child;\r\n                    if (childType === \"object\" && child.key !== undefined) {\r\n                        useKeys = useKeys || {};\r\n                        if (child.key in useKeys) {\r\n                            throw new Error(\r\n                                \"Each key must be unique among children\"\r\n                            );\r\n                        } else {\r\n                            useKeys[child.key] = true;\r\n                        }\r\n                    } else {\r\n                        if (useKeys) {\r\n                            throw new Error(\"Each child must have a key\");\r\n                        }\r\n                    }\r\n                    children.push(child);\r\n                }\r\n            }\r\n            return recicleChildren ? nextChildren : children;\r\n        };\r\n\r\n    for (let index in nextProps) {\r\n        let value = nextProps[index];\r\n        switch (index) {\r\n            case \"context\":\r\n                if (typeof value === \"object\") useContext = value;\r\n                continue;\r\n            case \"children\":\r\n                if (value === false) useChildren = false;\r\n                nextChildren = value;\r\n                continue;\r\n            case \"innerHTML\":\r\n            case \"textContent\":\r\n            case \"contenteditable\":\r\n                useChildren = false;\r\n                break;\r\n            case \"class\":\r\n                index = \"className\";\r\n                break;\r\n            case SHADOWDOM:\r\n                useShadowDom = value;\r\n                break;\r\n            case \"key\":\r\n                if (value === undefined) continue;\r\n                key = value = \"\" + value;\r\n                break;\r\n        }\r\n        props[index] = value;\r\n        size++;\r\n    }\r\n    children = mapChildren(nextChildren || []);\r\n    // children is empty, it is replaced by the constant, in order to compare the empty state\r\n    props.children = children = children.length ? children : EMPTY_CHILDREN;\r\n\r\n    return {\r\n        tag,\r\n        key,\r\n        size,\r\n        props,\r\n        children,\r\n        useKeys,\r\n        useContext,\r\n        useChildren,\r\n        useShadowDom\r\n    };\r\n}\r\n","import { update, createNode } from \"./update\";\r\nimport { defineVnode } from \"./vnode\";\r\nimport { NODE_TEXT, COMPONENT_REMOVE } from \"./constants\";\r\n/**\r\n * issue elimination to the entire tree of nodes\r\n * @param {string} ID\r\n * @param {HTMLElement|SVGElement|Text} node\r\n */\r\nexport function clearNode(ID, node) {\r\n    let { dispatch } = node[ID] || {},\r\n        nodeList = node.childNodes,\r\n        length = nodeList.length;\r\n    if (dispatch) dispatch(COMPONENT_REMOVE);\r\n    for (let i = 0; i < length; i++) {\r\n        clearNode(ID, nodeList[i]);\r\n    }\r\n}\r\n/**\r\n *\r\n * @param {string} ID\r\n * @param {HTMLElement|SVGElement|Text} node - node to extract current children\r\n * @param {object} vnextChildren  - list of children to update\r\n * @param {object|undefined} useKeys - index of keys to keep in the next update\r\n * @param {boolean} isSvg - define if it is a svg tree\r\n * @param {object} context - current context to share\r\n * @return {HTMLElement|SVGElement|Text}\r\n */\r\nexport function updateChildren(\r\n    ID,\r\n    node,\r\n    vnextChildren,\r\n    useKeys,\r\n    isSvg,\r\n    context\r\n) {\r\n    let nodeKeys = {},\r\n        nodeList = node.childNodes,\r\n        nodeListLength = nodeList.length,\r\n        vnodeListLength = vnextChildren.length,\r\n        /**\r\n         * modifies the start of the iteration based on the type whether it is using keys or indexes\r\n         * this is done for a deletion without iterate completely nodeList\r\n         */\r\n        nodeListIndexStart = useKeys\r\n            ? 0\r\n            : nodeListLength > vnodeListLength\r\n            ? vnodeListLength\r\n            : nodeListLength;\r\n    for (; nodeListIndexStart < nodeListLength; nodeListIndexStart++) {\r\n        let nodeChild = nodeList[nodeListIndexStart],\r\n            isRemove,\r\n            key = nodeListIndexStart;\r\n        // if the iteration uses keys, the node is stored in the index corresponding to its key\r\n        if (useKeys) {\r\n            key = nodeChild.dataset.key;\r\n            if (key in useKeys) {\r\n                nodeKeys[key] = nodeChild;\r\n            } else {\r\n                isRemove = true;\r\n            }\r\n        } else {\r\n            isRemove = true;\r\n        }\r\n        if (nodeChild && isRemove) {\r\n            clearNode(ID, nodeChild);\r\n            nodeListLength--;\r\n            nodeListIndexStart--;\r\n            node.removeChild(nodeChild);\r\n        }\r\n    }\r\n    for (let i = 0; i < vnodeListLength; i++) {\r\n        let vnode = defineVnode(vnextChildren[i]),\r\n            nextSibling = nodeList[i + 1],\r\n            useKey = useKeys ? vnode.key : i,\r\n            indexChild = nodeList[i],\r\n            prevChild = useKeys ? nodeKeys[vnode.key] : indexChild;\r\n\r\n        if (useKeys) {\r\n            if (prevChild !== indexChild) {\r\n                node.insertBefore(prevChild, indexChild);\r\n            }\r\n        }\r\n\r\n        // if it is a component and it does not have an associative node, it will create one to work within update\r\n        if (typeof vnode.tag === \"function\") {\r\n            if (!prevChild) {\r\n                prevChild = createNode(NODE_TEXT);\r\n                if (nextSibling) {\r\n                    node.insertBefore(prevChild, nextSibling);\r\n                } else {\r\n                    node.appendChild(prevChild);\r\n                }\r\n            }\r\n        }\r\n\r\n        let nextNode = update(ID, prevChild, vnode, isSvg, context);\r\n\r\n        if (!prevChild) {\r\n            if (nextSibling) {\r\n                node.insertBefore(nextNode, nextSibling);\r\n            } else {\r\n                node.appendChild(nextNode);\r\n            }\r\n        }\r\n    }\r\n}\r\n","/**\r\n * memorizes the transformations associated with the css properties.\r\n * @example\r\n * {borderRadius:\"50px\"} // {\"border-radius\" : \"50px\"}\r\n */\r\nconst CSS_PROPS = {};\r\n\r\n/**\r\n * Define the style property immutably\r\n * @param {HTMLElement|SVGAElement} node\r\n * @param {object|string} nextValue\r\n */\r\nexport function updateStyle(node, prevValue, nextValue) {\r\n    // this function has the previous state of the css directly from the node by the constant [CSS_VALUE]\r\n    let prevCss = prevValue,\r\n        nextCss = nextValue;\r\n    if (typeof nextValue === \"object\") {\r\n        nextCss = \"\";\r\n        for (let key in nextValue) {\r\n            if (!nextValue[key]) continue;\r\n            if (!CSS_PROPS[key]) {\r\n                CSS_PROPS[key] = key.replace(\r\n                    /([^A-Z])([A-Z])/g,\r\n                    (all, letterBefore, letterAfter) =>\r\n                        letterBefore + \"-\" + letterAfter.toLowerCase()\r\n                );\r\n            }\r\n            nextCss += `${CSS_PROPS[key]}:${nextValue[key]};`;\r\n        }\r\n    }\r\n\r\n    if (prevCss !== nextCss) {\r\n        node.style.cssText = nextCss;\r\n    }\r\n\r\n    return nextCss;\r\n}\r\n","import { options } from \"./options\";\r\nimport { EVENT_ALIAS } from \"./constants\";\r\n\r\nexport function updateEvent(node, type, prevHandler, nextHandler, handlers) {\r\n    if (type[0] !== \"o\" && type[1] !== \"n\") return;\r\n\r\n    if (!EVENT_ALIAS[type])\r\n        EVENT_ALIAS[type] = type.slice(2).toLocaleLowerCase();\r\n\r\n    type = EVENT_ALIAS[type];\r\n    if (!handlers[type]) {\r\n        handlers[type] = [event => handlers[type][1].call(event.target, event)];\r\n    }\r\n    let eventProxy = handlers[type][0];\r\n    if (prevHandler && !nextHandler) {\r\n        node.removeEventListener(type, eventProxy);\r\n        delete handlers[type];\r\n    } else {\r\n        if (!prevHandler && nextHandler) {\r\n            node.addEventListener(type, eventProxy);\r\n        }\r\n        handlers[type][1] = nextHandler;\r\n    }\r\n}\r\n","import { updateStyle } from \"./updateStyle\";\r\nimport { updateEvent } from \"./updateEvent\";\r\nimport { ATTRS_VALUE, SHADOWDOM } from \"./constants\";\r\n// properties to ignore by updateProperties\r\nconst IGNORE = {\r\n    children: 1\r\n};\r\n/**\r\n * define the properties of the node\r\n * @param {HTMLElement|SVGAElement} node\r\n * @param {object} nextProps\r\n * @param {boolean} isSvg\r\n */\r\nexport function updateProperties(node, nextProps, handlers, isSvg) {\r\n    let currentProps = node[ATTRS_VALUE] || {};\r\n    for (let key in currentProps) {\r\n        // IGNORE allows you to ignore a property.\r\n        if (IGNORE[key] || key === \"ref\") continue;\r\n        // If the property does not exist in the following definition, it is eliminated\r\n        if (!(key in nextProps)) {\r\n            if (key === \"key\") {\r\n                delete node.dataset.key;\r\n            } else if (key in node) {\r\n                node[key] = null;\r\n            } else {\r\n                node.removeAttribute(\r\n                    isSvg && key === \"xlink\" ? \"xlink:href\" : key\r\n                );\r\n            }\r\n            delete currentProps[key];\r\n        }\r\n    }\r\n    for (let key in nextProps) {\r\n        // IGNORE allows you to ignore a property.\r\n        if (IGNORE[key]) continue;\r\n\r\n        let isHandler;\r\n\r\n        let nextValue = nextProps[key],\r\n            typeNextValue = typeof nextValue;\r\n\r\n        let prevValue = key in handlers ? handlers[key] : currentProps[key],\r\n            typePrevValue = typeof prevValue;\r\n\r\n        if (nextValue === prevValue) continue;\r\n\r\n        if (key === \"key\") {\r\n            if (node.dataset.key !== nextValue) node.dataset.key = nextValue;\r\n            continue;\r\n        }\r\n        // updates the state of the ref object\r\n        if (key === \"ref\") {\r\n            if (nextValue) nextValue.current = node;\r\n            continue;\r\n        }\r\n\r\n        // Enables the use of shadowDom over the node\r\n        if (SHADOWDOM === key && \"attachShadow\" in node) {\r\n            if (\r\n                (node.shadowRoot && !nextValue) ||\r\n                (!node.shadowRoot && nextValue)\r\n            ) {\r\n                node.attachShadow({ mode: nextValue ? \"open\" : \"closed\" });\r\n            }\r\n            continue;\r\n        }\r\n\r\n        if (typeNextValue === \"function\" || typePrevValue === \"function\") {\r\n            updateEvent(node, key, prevValue, nextValue, handlers);\r\n            isHandler = true;\r\n        } else if ((key in node && !isSvg) || (isSvg && key === \"style\")) {\r\n            if (key === \"style\") {\r\n                nextValue = updateStyle(\r\n                    node,\r\n                    prevValue || node.style.cssText,\r\n                    nextValue\r\n                );\r\n            } else {\r\n                node[key] = nextValue;\r\n            }\r\n        } else {\r\n            isSvg\r\n                ? node.setAttributeNS(\r\n                      isSvg && key === \"xlink\"\r\n                          ? \"http://www.w3.org/1999/xlink\"\r\n                          : null,\r\n                      key === \"xlink\" ? \"xlink:href\" : key,\r\n                      nextValue\r\n                  )\r\n                : node.setAttribute(key, nextValue);\r\n        }\r\n        if (!isHandler) {\r\n            currentProps[key] = nextValue;\r\n        }\r\n    }\r\n    node[ATTRS_VALUE] = currentProps;\r\n}\r\n","import { options } from \"./options\";\r\nlet task = [],\r\n    defer = Promise.resolve();\r\n/**\r\n * allows to solve the pending tasks\r\n */\r\nfunction resolve() {\r\n    let currentTask = task,\r\n        length = currentTask.length;\r\n\r\n    task = [];\r\n\r\n    for (let i = 0; i < length; i++) {\r\n        let item = currentTask[i];\r\n        // discounts a level to the pending task, if it reaches 0 it is executed\r\n        if (--item.lvl) {\r\n            item.fun(item.arg);\r\n        } else {\r\n            // if the number of queued tasks is greater than\r\n            // options.maxConcurrentTask, the subsequent queue will be left\r\n            if (task.length > options.maxConcurrentTask) item.lvl++;\r\n            // Rescue the task to add it to the next queue\r\n            task.push(item);\r\n        }\r\n    }\r\n    // If there are remaining tasks, generate another cycle to clean the tasks\r\n    if (task.length) defer.then(resolve); //;setTimeout(() => defer.then(resolve));\r\n}\r\n/**\r\n * add a task to the waiting list\r\n * @param {function} fun - function to execute once the task has been solved.\r\n * @param {*} [arg] - argument to deliver to the task, once it is resolved\r\n * @param {number} [lvl] - level of importance 1 is important 2 is less important and so on\r\n */\r\nexport function setTask(fun, arg, lvl = 1) {\r\n    let length = task.length;\r\n    //if (length > options.maxConcurrentTask) lvl++;\r\n    task.push({ fun, arg, lvl });\r\n    // a cycle is created only if there is not one running\r\n    if (!length) {\r\n        defer.then(resolve);\r\n    }\r\n}\r\n","import { setTask } from \"./task\";\r\nimport {\r\n    COMPONENT_CREATE,\r\n    COMPONENT_UPDATE,\r\n    COMPONENT_CREATED,\r\n    COMPONENT_UPDATED,\r\n    COMPONENT_REMOVE\r\n} from \"./constants\";\r\n\r\nimport { update as updateNode } from \"./update\";\r\n\r\nlet CURRENT_SNAP, CURRENT_SNAP_KEY_HOOK;\r\n\r\nexport function getCurrentSnap() {\r\n    if (!CURRENT_SNAP) {\r\n        throw new Error(\r\n            \"the hooks can only be called from an existing functional component in the diff queue\"\r\n        );\r\n    }\r\n    return CURRENT_SNAP;\r\n}\r\n\r\nexport function useHook(reducer) {\r\n    let component = getCurrentSnap().component,\r\n        index = CURRENT_SNAP_KEY_HOOK++,\r\n        hook,\r\n        isCreate;\r\n    if (!component.hooks[index]) {\r\n        isCreate = true;\r\n        component.hooks[index] = {};\r\n    }\r\n    hook = component.hooks[index];\r\n    hook.reducer = reducer;\r\n    if (isCreate) dispatchHook(hook, { type: COMPONENT_CREATE });\r\n    return [hook.state, action => dispatchHook(hook, action)];\r\n}\r\n\r\nexport function dispatchHook(hook, action) {\r\n    hook.state = hook.reducer(hook.state, action);\r\n}\r\n\r\nexport function dispatchComponents(components, action) {\r\n    let length = components.length;\r\n    for (let i = 0; i < length; i++) {\r\n        let component = components[i],\r\n            hooks = component.hooks,\r\n            hooksLength = hooks.length;\r\n        if (action.type === COMPONENT_REMOVE) {\r\n            component.remove = true;\r\n        }\r\n        for (let i = 0; i < hooksLength; i++) {\r\n            dispatchHook(hooks[i], action);\r\n        }\r\n    }\r\n}\r\n/**\r\n * this function allows creating a block that analyzes the tag\r\n * defined as a function, in turn creates a global update scope for hook management.\r\n */\r\nexport function createUpdateComponent(ID, isSvg) {\r\n    let prevent,\r\n        store = [],\r\n        host;\r\n    /**\r\n     * This function allows reducing the functional components based on\r\n     * their return, in turn creates a unique state for each component\r\n     * according to a depth index\r\n     * @param {function} vnode\r\n     * @param {object} context\r\n     * @param {number} deep\r\n     */\r\n    function reduce(vnode, context, deep) {\r\n        // if host does not exist as a node, the vnode is not reduced\r\n        if (!host) return;\r\n        vnode = vnode || \"\";\r\n        // if it is different from a functional node, it is sent to updateNode again\r\n        if (typeof vnode.tag !== \"function\") {\r\n            dispatchComponents(store.splice(deep), {\r\n                type: COMPONENT_REMOVE\r\n            });\r\n            host = updateNode(ID, host, vnode, isSvg, context, updateComponent);\r\n            // if the store no longer has a length, it is assumed that the updateComponent is no longer necessary\r\n            if (store.length) host[ID].updateComponent = updateComponent;\r\n\r\n            return;\r\n        }\r\n        // you get the current component\r\n        let component = store[deep] || {},\r\n            isCreate,\r\n            useNext;\r\n        // if the current component is dis- torted to the analyzed one,\r\n        // the previous state is replaced with a new one and the elimination is dispatched.\r\n        if (component.tag !== vnode.tag) {\r\n            isCreate = true;\r\n            // the state of the component is defined\r\n            store[deep] = {\r\n                lvl: 1,\r\n                size: 1,\r\n                tag: vnode.tag,\r\n                hooks: [],\r\n                props: {},\r\n                context: {}\r\n            };\r\n            // the elimination is sent to the successors of the previous component\r\n            dispatchComponents(store.splice(deep + 1), {\r\n                type: COMPONENT_REMOVE\r\n            });\r\n            useNext = true;\r\n        }\r\n\r\n        component = store[deep];\r\n        // then a series of simple processes are carried out capable of\r\n        // identifying if the component requires an update\r\n        if (component.context !== vnode.useContext) {\r\n            // the current context is stored in the cache\r\n            component.context = vnode.useContext;\r\n            // create a new context\r\n            context = { ...context, ...vnode.useContext };\r\n            useNext = true;\r\n        }\r\n\r\n        if (!useNext) {\r\n            // compare the lake of properties\r\n            if (vnode.size !== component.size) useNext = true;\r\n            if (!useNext) {\r\n                // buy property by property, so the properties to be used\r\n                // in the areas must be immutable\r\n                for (let key in vnode.props) {\r\n                    if (vnode.props[key] !== component.props[key]) {\r\n                        useNext = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        component.props = vnode.props;\r\n        component.size = vnode.size;\r\n        /**\r\n         * this function is a snapshot of the current component,\r\n         * allows to run the component and launch the next update\r\n         */\r\n        function next() {\r\n            if (component.remove) return host;\r\n\r\n            CURRENT_SNAP = {\r\n                component,\r\n                context,\r\n                // allows access to the instantaneous, but it uses the microtareas\r\n                // to prevent multiple synchronous updates\r\n                next() {\r\n                    if (!component.prevent) {\r\n                        component.prevent = true;\r\n                        setTask(() => {\r\n                            component.prevent = false;\r\n                            next();\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n\r\n            CURRENT_SNAP_KEY_HOOK = 0;\r\n\r\n            dispatchComponents([component], { type: COMPONENT_UPDATE });\r\n\r\n            let vnextnode = component.tag(component.props, context);\r\n\r\n            CURRENT_SNAP = false;\r\n            CURRENT_SNAP_KEY_HOOK = 0;\r\n\r\n            reduce(vnextnode, context, deep + 1);\r\n\r\n            dispatchComponents([component], {\r\n                type: isCreate ? COMPONENT_CREATED : COMPONENT_UPDATED\r\n            });\r\n\r\n            isCreate = false;\r\n        }\r\n\r\n        if (useNext && !component.prevent) next();\r\n    }\r\n    /**\r\n     *\r\n     * @param {string} type\r\n     * @param {HTMLElement|SVGElement|Text} nextHost\r\n     * @param {object} vnode\r\n     * @param {object} context\r\n     */\r\n    function updateComponent(type, nextHost, vnode, context) {\r\n        switch (type) {\r\n            case COMPONENT_UPDATE:\r\n                host = nextHost;\r\n                reduce(vnode, context, 0);\r\n                return host;\r\n            case COMPONENT_REMOVE:\r\n                host = false;\r\n                dispatchComponents(history, { type });\r\n                history = [];\r\n                break;\r\n        }\r\n    }\r\n\r\n    return updateComponent;\r\n}\r\n","import { NODE_TEXT, NODE_HOST, TAG_VALUE, COMPONENT_UPDATE } from \"./constants\";\r\nimport { options } from \"./options\";\r\nimport { defineVnode } from \"./vnode\";\r\nimport { updateChildren } from \"./updateChildren\";\r\nimport { updateProperties } from \"./updateProperties\";\r\nimport { createUpdateComponent } from \"./component\";\r\nimport { setTask } from \"./task\";\r\nimport { createVnode } from \"./vnode\";\r\n/**\r\n * @param {object} vnode\r\n * @param {HTMLElement|SVGElement} node\r\n * @param {string} [customID]\r\n * @param {boolean} disableHost\r\n */\r\nexport function render(vnode, node, customID = \"vstate\", disableHost) {\r\n    if (!disableHost) {\r\n        vnode = defineVnode(vnode);\r\n        if (vnode.tag !== NODE_HOST) {\r\n            vnode = createVnode(NODE_HOST, {}, [vnode]);\r\n        }\r\n    }\r\n    update(customID, node, vnode);\r\n}\r\n\r\nexport function createNode(tag, isSvg) {\r\n    let doc = options.document || document,\r\n        nextNode;\r\n    if (tag !== NODE_TEXT) {\r\n        nextNode = isSvg\r\n            ? doc.createElementNS(\"http://www.w3.org/2000/svg\", tag)\r\n            : doc.createElement(tag);\r\n    } else {\r\n        nextNode = doc.createTextNode(\"\");\r\n    }\r\n    nextNode[TAG_VALUE] = tag;\r\n    return nextNode;\r\n}\r\n\r\nexport function getNodeName(node) {\r\n    if (!node) return;\r\n    // store the process locally in the node to avoid transformation\r\n    if (!node[TAG_VALUE]) {\r\n        node[TAG_VALUE] = node.nodeName.toLowerCase();\r\n    }\r\n    return node[TAG_VALUE];\r\n}\r\n/**\r\n *\r\n * @param {string} ID - store the process locally in the node to avoid transformation\r\n * @param {HTMLElement|SVGElement|Text|undefined} prevNode - if the current node is defined and the next\r\n * one to be used is different, the replacement of the current node will be made\r\n * @param {*} vnode\r\n * @param {boolean} isSvg\r\n * @param {object} context\r\n * @param {function|undefined} currentUpdateComponent\r\n */\r\nexport function update(\r\n    ID,\r\n    prevNode,\r\n    vnode,\r\n    isSvg,\r\n    context,\r\n    currentUpdateComponent\r\n) {\r\n    // get a node object\r\n    vnode = defineVnode(vnode);\r\n    // if the previous state exists, it obtains the state\r\n    let { vnode: vprevnode, handlers = {}, updateComponent } =\r\n        (prevNode && prevNode[ID]) || {};\r\n    // if the node stored in the previous state is identical to the current one,\r\n    // it will not execute the update process\r\n    if (vnode === vprevnode) return prevNode;\r\n\r\n    let {\r\n        // defines the next node to manipulate the concurrent tree\r\n        tag: nextTag,\r\n        // define the properties that the next node must possess\r\n        props: nextProps,\r\n        // define the children that this node must possess in the following state\r\n        children: nextChildren,\r\n        // transmits keys to the updateChildren that is kept in the children list\r\n        useKeys,\r\n        // define if they would use updateChildren\r\n        useChildren,\r\n        // define if shadowDom was used\r\n        useShadowDom\r\n    } = vnode;\r\n    // define if the tree is of the SVG type\r\n    isSvg = isSvg || nextTag === \"svg\";\r\n\r\n    let nextNode = prevNode,\r\n        isFunction = typeof nextTag === \"function\";\r\n\r\n    // create an updateComponent\r\n    if (isFunction && !updateComponent) {\r\n        updateComponent = createUpdateComponent(ID, isSvg);\r\n    }\r\n\r\n    if (\r\n        getNodeName(prevNode) !== nextTag &&\r\n        nextTag !== \"host\" &&\r\n        !isFunction\r\n    ) {\r\n        nextNode = createNode(nextTag, isSvg);\r\n        handlers = {};\r\n        if (prevNode) {\r\n            prevNode.parentNode.replaceChild(nextNode, prevNode);\r\n        }\r\n    }\r\n    if (updateComponent && currentUpdateComponent !== updateComponent) {\r\n        return updateComponent(COMPONENT_UPDATE, nextNode, vnode, context);\r\n    } else if (nextTag !== NODE_TEXT) {\r\n        updateProperties(nextNode, nextProps, handlers, isSvg);\r\n        if (useChildren && (vprevnode || {}).children !== vnode.children) {\r\n            updateChildren(\r\n                ID,\r\n                useShadowDom ? nextNode.shadowRoot || nextNode : nextNode,\r\n                nextChildren,\r\n                useKeys,\r\n                isSvg,\r\n                context\r\n            );\r\n        }\r\n    } else {\r\n        if (nextNode.nodeValue !== nextChildren) {\r\n            nextNode.nodeValue = nextChildren;\r\n        }\r\n    }\r\n\r\n    nextNode[ID] = { handlers, vnode, updateComponent };\r\n\r\n    return nextNode;\r\n}\r\n","import { getCurrentSnap, useHook } from \"./component\";\r\n\r\nimport { isEqualArray } from \"./utils\";\r\n\r\nimport {\r\n    COMPONENT_CREATE,\r\n    COMPONENT_CREATED,\r\n    COMPONENT_UPDATE,\r\n    COMPONENT_UPDATED,\r\n    COMPONENT_REMOVE,\r\n    COMPONENT_CLEAR\r\n} from \"./constants\";\r\n\r\nexport function useState(initialState) {\r\n    let next = getCurrentSnap().next,\r\n        type = \"useState/update\";\r\n    let [state, dispatch] = useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n                return typeof initialState === \"function\"\r\n                    ? initialState()\r\n                    : initialState;\r\n            case type:\r\n                let nextState = action.state;\r\n                return typeof nextState === \"function\"\r\n                    ? nextState(state)\r\n                    : nextState;\r\n        }\r\n        return state;\r\n    });\r\n    return [\r\n        state,\r\n        state => {\r\n            dispatch({ state, type });\r\n            next();\r\n        }\r\n    ];\r\n}\r\n\r\nexport function useEffect(callback, args) {\r\n    useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n                return { args };\r\n            case COMPONENT_UPDATE:\r\n            case COMPONENT_REMOVE:\r\n                if (state.clear) {\r\n                    let next =\r\n                        action.type === COMPONENT_REMOVE ||\r\n                        (args && state.args\r\n                            ? !isEqualArray(args, state.args)\r\n                            : true);\r\n                    if (next) state.clear();\r\n                }\r\n                return { ...state, args };\r\n            case COMPONENT_CREATED:\r\n            case COMPONENT_UPDATED:\r\n                let next =\r\n                        action.type === COMPONENT_CREATED ||\r\n                        (args && state.args\r\n                            ? !isEqualArray(args, state.args)\r\n                            : true),\r\n                    clear = state.clear;\r\n                if (next) {\r\n                    clear = callback();\r\n                }\r\n                return { ...state, clear, args };\r\n        }\r\n        return state;\r\n    });\r\n}\r\n\r\nexport function useRef(current) {\r\n    let [state] = useHook((state = {}, action) =>\r\n        action.type === COMPONENT_CREATE ? { current } : state\r\n    );\r\n    return state;\r\n}\r\n\r\nexport function useMemo(callback, args) {\r\n    let [state] = useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n            case COMPONENT_UPDATE:\r\n                return {\r\n                    args,\r\n                    value:\r\n                        action.type === COMPONENT_CREATE\r\n                            ? callback()\r\n                            : isEqualArray(args, state.args)\r\n                            ? state.value\r\n                            : callback()\r\n                };\r\n        }\r\n        return state;\r\n    });\r\n    return state.value;\r\n}\r\n\r\nexport function useReducer(reducer, initialState) {\r\n    let next = getCurrentSnap().next,\r\n        type = \"useReducer/update\";\r\n    let [state, dispatch] = useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n                return initialState;\r\n            case type:\r\n                return reducer(state, action.use);\r\n        }\r\n        return state;\r\n    });\r\n    return [\r\n        state,\r\n        use => {\r\n            dispatch({ type, use });\r\n            next();\r\n        }\r\n    ];\r\n}\r\n","import { h, render, useEffect, useState } from \"../../../src/index\";\r\n\r\nfunction Table(props) {\r\n    return (\r\n        <table class=\"table table-striped latest-data\">\r\n            <tbody>\r\n                {props.dbs.map(data => (\r\n                    <tr>\r\n                        <td class=\"dbname\">{data.dbname}</td>\r\n\r\n                        <td class=\"query-count\">\r\n                            <span class={data.lastSample.countClassName}>\r\n                                {data.lastSample.nbQueries}\r\n                            </span>\r\n                        </td>\r\n                        {data.lastSample.topFiveQueries.map(data => (\r\n                            <td class={\"Query \" + data.elapsedClassName}>\r\n                                {data.formatElapsed}\r\n                                <div class=\"popover left\">\r\n                                    <div class=\"popover-content\">\r\n                                        {data.query}\r\n                                    </div>\r\n                                    <div class=\"arrow\" />\r\n                                </div>\r\n                            </td>\r\n                        ))}\r\n                    </tr>\r\n                ))}\r\n            </tbody>\r\n        </table>\r\n    );\r\n}\r\n\r\nperfMonitor.startFPSMonitor();\r\nperfMonitor.startMemMonitor();\r\nperfMonitor.initProfiler(\"view update\");\r\n\r\nfunction getData() {\r\n    return ENV.generateData().toArray();\r\n}\r\n\r\nfunction Rerender() {\r\n    perfMonitor.startProfile(\"view update\");\r\n    let [state, setState] = useState(getData);\r\n    useEffect(() => {\r\n        function loop() {\r\n            setState(getData());\r\n            setTimeout(loop, ENV.timeout);\r\n        }\r\n        loop();\r\n    }, []);\r\n    useEffect(() => {\r\n        perfMonitor.endProfile(\"view update\");\r\n    });\r\n    return <Table dbs={state} />;\r\n}\r\n\r\nrender(<Rerender />, document.getElementById(\"body\"));\r\n"],"names":["const","NODE_TEXT","NODE_HOST","TAG_VALUE","ATTRS_VALUE","SHADOWDOM","COMPONENT_CREATE","COMPONENT_UPDATE","COMPONENT_CREATED","COMPONENT_UPDATED","COMPONENT_REMOVE","EMPTY_CHILDREN","EVENT_ALIAS","options","maxConcurrentTask","isArray","value","Array","isEqualArray","before","after","let","length","i","h","tag","props","createVnode","children","defineVnode","type","nextProps","nextChildren","useKeys","key","useContext","useShadowDom","size","useChildren","mapChildren","deep","recicleChildren","child","undefined","Error","push","index","clearNode","ID","node","nodeList","childNodes","dispatch","CSS_PROPS","updateStyle","prevValue","nextValue","prevCss","nextCss","replace","all","letterBefore","letterAfter","toLowerCase","style","cssText","updateEvent","prevHandler","nextHandler","handlers","slice","toLocaleLowerCase","event","call","target","eventProxy","removeEventListener","addEventListener","IGNORE","CURRENT_SNAP","CURRENT_SNAP_KEY_HOOK","vnode","customID","disableHost","task","defer","Promise","resolve","currentTask","item","lvl","fun","arg","then","getCurrentSnap","useHook","reducer","hook","isCreate","component","hooks","dispatchHook","state","action","dispatchComponents","components","hooksLength","remove","createUpdateComponent","isSvg","host","store","reduce","context","splice","updateNode","updateComponent","useNext","Object","prevent","next","setTask","vnextnode","nextHost","history","createNode","nextNode","doc","document","createElementNS","createElement","createTextNode","update","prevNode","currentUpdateComponent","vprevnode","nextTag","isFunction","nodeName","getNodeName","parentNode","replaceChild","currentProps","dataset","removeAttribute","isHandler","typeNextValue","typePrevValue","shadowRoot","attachShadow","mode","setAttributeNS","setAttribute","current","updateProperties","vnextChildren","nodeKeys","nodeListLength","vnodeListLength","nodeListIndexStart","nodeChild","isRemove","removeChild","nextSibling","indexChild","prevChild","insertBefore","appendChild","updateChildren","nodeValue","useEffect","callback","args","clear","Table","class","dbs","map","data","dbname","lastSample","countClassName","nbQueries","topFiveQueries","elapsedClassName","formatElapsed","query","getData","ENV","generateData","toArray","perfMonitor","startFPSMonitor","startMemMonitor","initProfiler","startProfile","initialState","nextState","useState","loop","setState","setTimeout","timeout","endProfile","getElementById"],"mappings":"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"}