## hooks

Atomico uses the hook pattern implemented by React to enhance the use of web-componts, in turn introduces exclusive hooks for web-componts, with the intention of improving the development experience.

| Name                                        | Description                                                                                                                                                                      | Example                                                     |
| ------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- |
| [useState](#usestate)                       | Allows the creation of one or more states for the component                                                                                                                      | [link](https://webcomponents.dev/edit/3QSxaypfCDqwwwkUvmVu) |
| [useEffect](#useeffect)                     | Allows you to add side effects for the component                                                                                                                                 |                                                             |
| [useReducer](#usereduce)                    | Allows to use the redux pattern to control the state of the component                                                                                                            |                                                             |
| [useMemo](#usememo)                         | Allows to optimize the execution of complex processes, by means of return memorization                                                                                           |                                                             |
| [useRef](#useref)                           | Allows you to create a constant object between updates                                                                                                                           |                                                             |
| [useHost](#usehost)                         | **Exclusive for web-components**, allows to obtain a reference on the web-component node in reference format, eg `{current: node}`                                               |                                                             |
| [useProp](#useprops)                        | **Exclusive to web-components**, it allows you to interact with a property of the web component, it is similar to `useState`, but this reflects the status in the web-component. |                                                             |
| [useEvent](#useevent)                       | **exclusive for web-components**, allows you to create a callback that dispatches an event from the web-component.                                                               |                                                             |
| [useProvider](#useprovider-and-useconsumer) | **exclusive to web-components**, allows you to create a parent state to share towards your children.                                                                             |                                                             |
| [useConsumer](#useprovider-and-useconsumer) | **exclusive to web-components**, allows you to consume a parent state generated by `useProvider`                                                                                 |                                                             |

### useState

```js
let [state, setState] = useState(initialState);
```

`setState` function, allows controlling one or more states associated with a component, the declaration`let [state, setState]`, is equivalent to:

1. `state` : current state
2. `setState` : status updater, if `setState` receives a function as a parameter it will receive and must return the next state.

#### Example

```jsx
function WebComponent() {
	let [state, setState] = useState(0);
	return (
		<host>
			<h1>example counter</h1>
			<button onClick={() => setState(state + 1)}>Increment</button>
		</host>
	);
}
```

### useEffect

```js
useEffect(afterRender);
```

`useEffect` function allows you to add side effects to a component.

```jsx
function WebComponent() {
	useEffect(() => {
		document.head.title = "web-component mounted";
		return () => (document.head.title = "web-component unmounted");
	}, []);

	return (
		<host>
			<h1>example useEffect</h1>
		</host>
	);
}
```

> useEffect, supports a second matrix of type of parameter, this allows to compare between renders the immutability of the parameters of the array, if there is a change useEffect will be executed again, **the previous example will execute the function only when the component has been mounted.**

### useReducer

```js
let [state, dispatch] = useReducer(reducer, initialState);
```

`useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.

```jsx
const initialState = { count: 0 };

function reducer(state, action) {
	switch (action.type) {
		case "increment":
			return { count: state.count + 1 };
		case "decrement":
			return { count: state.count - 1 };
		default:
			throw new Error();
	}
}

function WebComponent() {
	let [state, dispatch] = useReducer(reducer, initialState);
	return (
		<host>
			Count: {state.count}
			<button onClick={() => dispatch({ type: "increment" })}>+</button>
			<button onClick={() => dispatch({ type: "decrement" })}>-</button>
		</host>
	);
}
```

### useMemo

```jsx
let memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

`useMemo` will only recalculate the stored value when one of the dependencies has changed. This optimization helps avoid costly calculations in each render.

### useRef

```jsx
let ref = useRef(initialValue);
```

`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument (initialValue). The returned object will persist for the full lifetime of the component.

### useHost

```jsx
let ref = useHost();
```

Returns a ref object, which allows to extract extract the web-component, it is ideal for the construction of hooks that interact with web-components directly.

### useEvent

useEvent allows you to dispatch a custom Event from the web-component, this hook accepts 2 parameters:

1. name of the event
2. [native configuration of the event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event), this is optional.

```jsx
let optionalConfig = {
	bubbles: true
};
function WebComponent() {
	let dispatchMyCustomEvent = useEvent("MyCustomEvent", optionalConfig);
	return <host onclick={dispatchMyCustomEvent} />;
}

document
	.querySelector("web-component")
	.addEventListener("MyCustomEvent", handler);
```

### useProp

useProp allows, the state of one of the props, previously defined. **useProp requires the previous definition of the props of the web-component**

```jsx
let [myProp, setMyProp] = useProp("myProp");
```

> The behavior is similar to `useState`, but with the difference that useProp, it makes the value visible from the web-component, eg:

```jsx
document.querySelector("web-component").myProp; // will always own the last state of the property
```

> Consider the use of useProps on useState, when you need to read the status modified by the web-component's logic.

### useProvider and useConsumer

This hook works in conjunction with `useConsumer`, it allows to generate a state a shared state between web-components, the state that shares this hooks propagates from the web-component that declares`useProvider` towards its children that declare `useConsumer`.

> This hooks is able to avoid the blocking of memo, since it works thanks to event.bubbles.

> This hooks allows an optimized communication between web-components regardless of who or what structure the DOM.

```jsx
// Thanks to Symbol, the name of the event will be unique, eg I2NoYW5uZWwtLTE=
let CHANNEL = Symbol();
// This value is optional and allows to communicate an initial state
let initialState = { any: "value" };

function WebComponentParent() {
	let [state, setState] = useProvider(CHANNEL, initialState);
	return (
		<host>
			<pre>{state.any}</pre>
			<slot />
		</host>
	);
}

function WebComponentChild() {
	let [state, setState] = useConsumer(CHANNEL);
	return (
		<host>
			<pre>{state.any}</pre>
			<input oninput={({target})=>setState(target.value)}>
		</host>
	);
}
```

> the previous example, if the `WebComponentParent` nests with `WebComponentChild`, the latter controls the state between these 2 web-components, this behavior is useful for synchronizing ui, eg `tabs`

by default userConsumer, update the web-component when using `setState`, but you can prevent this by defining a function as a second parameter, in this way the update is subject to customization,eg:

```jsx
let [state, setState] = useState();
useConsumer(CHANNEL, function handler([parentState]) {
	setState(parentState);
});
```
