{"version":3,"file":"bundle.js","sources":["../../../src/constants.js","../../../src/options.js","../../../src/utils.js","../../../src/vnode.js","../../../src/updateChildren.js","../../../src/updateStyle.js","../../../src/updateEvent.js","../../../src/updateProperties.js","../../../src/task.js","../../../src/component.js","../../../src/update.js","../../../src/hooks.js","../src/dot.js","../src/triangle.js","../src/index.js"],"sourcesContent":["export const NODE_TEXT = \"#text\";\r\nexport const NODE_HOST = \"host\";\r\n\r\nexport const TAG_VALUE = \"@tag\";\r\n\r\nexport const CSS_VALUE = \"@css\";\r\n\r\nexport const ATTRS_VALUE = \"@attrs\";\r\n\r\nexport const SHADOWDOM = \"shadowDom\";\r\n\r\nexport const COMPONENT_CREATE = \"@create\";\r\nexport const COMPONENT_UPDATE = \"@update\";\r\nexport const COMPONENT_CREATED = \"@created\";\r\nexport const COMPONENT_UPDATED = \"@updated\";\r\nexport const COMPONENT_CLEAR = \"@clear\";\r\nexport const COMPONENT_REMOVE = \"@remove\";\r\n/**\r\n * if a list of children is empty in content it is\r\n * replaced by this constant with the intention\r\n * of simplifying the immutable comparison\r\n */\r\nexport const EMPTY_CHILDREN = [];\r\n/**\r\n * stores the transformations created in update Event,\r\n * by manipulating the name of the event\r\n */\r\nexport const EVENT_ALIAS = {};\r\n\r\nexport const CONTEXT = \"@ctx.\";\r\n","export let options = {\r\n    // defines the maximum amount of simultaneous tasks\r\n    maxConcurrentTask: 5000\r\n};\r\n","/**\r\n * Return if value is array\r\n * @param {*}\r\n * @return {boolean}\r\n */\r\nexport function isArray(value) {\r\n    return Array.isArray(value);\r\n}\r\n/**\r\n * compare 2 array\r\n * @param {array} before\r\n * @param {array} after\r\n * @example\r\n * isEqualArray([1,2,3,4],[1,2,3,4]) // true\r\n * isEqualArray([1,2,3,4],[1,2,3])   // false\r\n * isEqualArray([5,1,2,3],[1,2,3,5]) // false\r\n * isEqualArray([],[]) // true\r\n * @returns {boolean}\r\n */\r\nexport function isEqualArray(before, after) {\r\n    let length = before.length;\r\n    if (length !== after.length) return false;\r\n    for (let i = 0; i < length; i++) {\r\n        if (before[i] !== after[i]) return false;\r\n    }\r\n    return true;\r\n}\r\n","import { isArray } from \"./utils\";\r\nimport { EMPTY_CHILDREN, SHADOWDOM } from \"./constants\";\r\n/**\r\n * allows to transfer the arguments to createVnode\r\n * @param {string|function} tag - define the vnode to work\r\n * @param {object} [props] - vnode properties\r\n * @param {array} [children] - properties to be transmitted to the vnode\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return createVnode(tag, props, children);\r\n}\r\n/**\r\n * if the vnode is defined different from an object, it returns a vnode that creates a text node\r\n * @param {*} value\r\n * @return {object}\r\n */\r\nexport function defineVnode(value) {\r\n    let type = typeof value;\r\n    if (type === \"object\" && value.tag) {\r\n        return value;\r\n    } else {\r\n        return {\r\n            tag: \"#text\",\r\n            children: type === \"number\" || type === \"string\" ? \"\" + value : \"\"\r\n        };\r\n    }\r\n}\r\n/**\r\n * create a representative object of the node to be created, updated or deleted\r\n * @param {string|function} tag - type of node to represent\r\n * @param {object} nextProps - properties of the node to represent\r\n * @param {array} nextChildren - children of the node to represent\r\n */\r\nexport function createVnode(tag, nextProps, nextChildren) {\r\n    nextProps = nextProps || {};\r\n    // Increase the indexes to be reused.\r\n    let useKeys,\r\n        // key identifier\r\n        key,\r\n        // list of children\r\n        children,\r\n        // amount of props\r\n        size = 1,\r\n        // Tag properties\r\n        props = {},\r\n        // define whether the node will update the context\r\n        useContext,\r\n        // announces that the node will use shadowDom\r\n        useShadowDom,\r\n        // lets you ignore updateChildren\r\n        useChildren = true,\r\n        // scan the children recursively to form a list without depth\r\n        mapChildren = (nextChildren, deep = 0, children = []) => {\r\n            let length = nextChildren.length,\r\n                recicleChildren = true;\r\n            // allows recycling to nextChildren, if the condition is met\r\n            while (!deep && length === 1 && isArray(nextChildren[0])) {\r\n                nextChildren = nextChildren[0];\r\n                length = nextChildren.length;\r\n            }\r\n\r\n            for (let i = 0; i < length; i++) {\r\n                let child = nextChildren[i];\r\n                if (isArray(child)) {\r\n                    mapChildren(child, deep + 1, children);\r\n                    recicleChildren = false;\r\n                } else {\r\n                    let childType = typeof child;\r\n                    if (childType === \"object\" && child.key !== undefined) {\r\n                        useKeys = useKeys || {};\r\n                        if (child.key in useKeys) {\r\n                            throw new Error(\r\n                                \"Each key must be unique among children\"\r\n                            );\r\n                        } else {\r\n                            useKeys[child.key] = true;\r\n                        }\r\n                    } else {\r\n                        if (useKeys) {\r\n                            throw new Error(\"Each child must have a key\");\r\n                        }\r\n                    }\r\n                    children.push(child);\r\n                }\r\n            }\r\n            return recicleChildren ? nextChildren : children;\r\n        };\r\n\r\n    for (let index in nextProps) {\r\n        let value = nextProps[index];\r\n        switch (index) {\r\n            case \"context\":\r\n                if (typeof value === \"object\") useContext = value;\r\n                continue;\r\n            case \"children\":\r\n                if (value === false) useChildren = false;\r\n                nextChildren = value;\r\n                continue;\r\n            case \"innerHTML\":\r\n            case \"textContent\":\r\n            case \"contenteditable\":\r\n                useChildren = false;\r\n                break;\r\n            case \"class\":\r\n                index = \"className\";\r\n                break;\r\n            case SHADOWDOM:\r\n                useShadowDom = value;\r\n                break;\r\n            case \"key\":\r\n                if (value === undefined) continue;\r\n                key = value = \"\" + value;\r\n                break;\r\n        }\r\n        props[index] = value;\r\n        size++;\r\n    }\r\n    children = mapChildren(nextChildren || []);\r\n    // children is empty, it is replaced by the constant, in order to compare the empty state\r\n    props.children = children = children.length ? children : EMPTY_CHILDREN;\r\n\r\n    return {\r\n        tag,\r\n        key,\r\n        size,\r\n        props,\r\n        children,\r\n        useKeys,\r\n        useContext,\r\n        useChildren,\r\n        useShadowDom\r\n    };\r\n}\r\n","import { update, createNode } from \"./update\";\r\nimport { defineVnode } from \"./vnode\";\r\nimport { NODE_TEXT, COMPONENT_REMOVE } from \"./constants\";\r\n/**\r\n * issue elimination to the entire tree of nodes\r\n * @param {string} ID\r\n * @param {HTMLElement|SVGElement|Text} node\r\n */\r\nexport function clearNode(ID, node) {\r\n    let { dispatch } = node[ID] || {},\r\n        nodeList = node.childNodes,\r\n        length = nodeList.length;\r\n    if (dispatch) dispatch(COMPONENT_REMOVE);\r\n    for (let i = 0; i < length; i++) {\r\n        clearNode(ID, nodeList[i]);\r\n    }\r\n}\r\n/**\r\n *\r\n * @param {string} ID\r\n * @param {HTMLElement|SVGElement|Text} node - node to extract current children\r\n * @param {object} vnextChildren  - list of children to update\r\n * @param {object|undefined} useKeys - index of keys to keep in the next update\r\n * @param {boolean} isSvg - define if it is a svg tree\r\n * @param {object} context - current context to share\r\n * @return {HTMLElement|SVGElement|Text}\r\n */\r\nexport function updateChildren(\r\n    ID,\r\n    node,\r\n    vnextChildren,\r\n    useKeys,\r\n    isSvg,\r\n    context\r\n) {\r\n    let nodeKeys = {},\r\n        nodeList = node.childNodes,\r\n        nodeListLength = nodeList.length,\r\n        vnodeListLength = vnextChildren.length,\r\n        /**\r\n         * modifies the start of the iteration based on the type whether it is using keys or indexes\r\n         * this is done for a deletion without iterate completely nodeList\r\n         */\r\n        nodeListIndexStart = useKeys\r\n            ? 0\r\n            : nodeListLength > vnodeListLength\r\n            ? vnodeListLength\r\n            : nodeListLength;\r\n    for (; nodeListIndexStart < nodeListLength; nodeListIndexStart++) {\r\n        let nodeChild = nodeList[nodeListIndexStart],\r\n            isRemove,\r\n            key = nodeListIndexStart;\r\n        // if the iteration uses keys, the node is stored in the index corresponding to its key\r\n        if (useKeys) {\r\n            key = nodeChild.dataset.key;\r\n            if (key in useKeys) {\r\n                nodeKeys[key] = nodeChild;\r\n            } else {\r\n                isRemove = true;\r\n            }\r\n        } else {\r\n            isRemove = true;\r\n        }\r\n        if (nodeChild && isRemove) {\r\n            clearNode(ID, nodeChild);\r\n            nodeListLength--;\r\n            nodeListIndexStart--;\r\n            node.removeChild(nodeChild);\r\n        }\r\n    }\r\n    for (let i = 0; i < vnodeListLength; i++) {\r\n        let vnode = defineVnode(vnextChildren[i]),\r\n            nextSibling = nodeList[i + 1],\r\n            useKey = useKeys ? vnode.key : i,\r\n            indexChild = nodeList[i],\r\n            prevChild = useKeys ? nodeKeys[vnode.key] : indexChild;\r\n\r\n        if (useKeys) {\r\n            if (prevChild !== indexChild) {\r\n                node.insertBefore(prevChild, indexChild);\r\n            }\r\n        }\r\n\r\n        // if it is a component and it does not have an associative node, it will create one to work within update\r\n        if (typeof vnode.tag === \"function\") {\r\n            if (!prevChild) {\r\n                prevChild = createNode(NODE_TEXT);\r\n                if (nextSibling) {\r\n                    node.insertBefore(prevChild, nextSibling);\r\n                } else {\r\n                    node.appendChild(prevChild);\r\n                }\r\n            }\r\n        }\r\n\r\n        let nextNode = update(ID, prevChild, vnode, isSvg, context);\r\n\r\n        if (!prevChild) {\r\n            if (nextSibling) {\r\n                node.insertBefore(nextNode, nextSibling);\r\n            } else {\r\n                node.appendChild(nextNode);\r\n            }\r\n        }\r\n    }\r\n}\r\n","/**\r\n * memorizes the transformations associated with the css properties.\r\n * @example\r\n * {borderRadius:\"50px\"} // {\"border-radius\" : \"50px\"}\r\n */\r\nconst CSS_PROPS = {};\r\n\r\n/**\r\n * Define the style property immutably\r\n * @param {HTMLElement|SVGAElement} node\r\n * @param {object|string} nextValue\r\n */\r\nexport function updateStyle(node, prevValue, nextValue) {\r\n    // this function has the previous state of the css directly from the node by the constant [CSS_VALUE]\r\n    let prevCss = prevValue,\r\n        nextCss = nextValue;\r\n    if (typeof nextValue === \"object\") {\r\n        nextCss = \"\";\r\n        for (let key in nextValue) {\r\n            if (!nextValue[key]) continue;\r\n            if (!CSS_PROPS[key]) {\r\n                CSS_PROPS[key] = key.replace(\r\n                    /([^A-Z])([A-Z])/g,\r\n                    (all, letterBefore, letterAfter) =>\r\n                        letterBefore + \"-\" + letterAfter.toLowerCase()\r\n                );\r\n            }\r\n            nextCss += `${CSS_PROPS[key]}:${nextValue[key]};`;\r\n        }\r\n    }\r\n\r\n    if (prevCss !== nextCss) {\r\n        node.style.cssText = nextCss;\r\n    }\r\n\r\n    return nextCss;\r\n}\r\n","import { options } from \"./options\";\r\nimport { EVENT_ALIAS } from \"./constants\";\r\n\r\nexport function updateEvent(node, type, prevHandler, nextHandler, handlers) {\r\n    if (type[0] !== \"o\" && type[1] !== \"n\") return;\r\n\r\n    if (!EVENT_ALIAS[type])\r\n        EVENT_ALIAS[type] = type.slice(2).toLocaleLowerCase();\r\n\r\n    type = EVENT_ALIAS[type];\r\n    if (!handlers[type]) {\r\n        handlers[type] = [event => handlers[type][1].call(event.target, event)];\r\n    }\r\n    let eventProxy = handlers[type][0];\r\n    if (prevHandler && !nextHandler) {\r\n        node.removeEventListener(type, eventProxy);\r\n        delete handlers[type];\r\n    } else {\r\n        if (!prevHandler && nextHandler) {\r\n            node.addEventListener(type, eventProxy);\r\n        }\r\n        handlers[type][1] = nextHandler;\r\n    }\r\n}\r\n","import { updateStyle } from \"./updateStyle\";\r\nimport { updateEvent } from \"./updateEvent\";\r\nimport { ATTRS_VALUE, SHADOWDOM } from \"./constants\";\r\n// properties to ignore by updateProperties\r\nconst IGNORE = {\r\n    children: 1\r\n};\r\n/**\r\n * define the properties of the node\r\n * @param {HTMLElement|SVGAElement} node\r\n * @param {object} nextProps\r\n * @param {boolean} isSvg\r\n */\r\nexport function updateProperties(node, nextProps, handlers, isSvg) {\r\n    let currentProps = node[ATTRS_VALUE] || {};\r\n    for (let key in currentProps) {\r\n        // IGNORE allows you to ignore a property.\r\n        if (IGNORE[key] || key === \"ref\") continue;\r\n        // If the property does not exist in the following definition, it is eliminated\r\n        if (!(key in nextProps)) {\r\n            if (key === \"key\") {\r\n                delete node.dataset.key;\r\n            } else if (key in node) {\r\n                node[key] = null;\r\n            } else {\r\n                node.removeAttribute(\r\n                    isSvg && key === \"xlink\" ? \"xlink:href\" : key\r\n                );\r\n            }\r\n            delete currentProps[key];\r\n        }\r\n    }\r\n    for (let key in nextProps) {\r\n        // IGNORE allows you to ignore a property.\r\n        if (IGNORE[key]) continue;\r\n\r\n        let isHandler;\r\n\r\n        let nextValue = nextProps[key],\r\n            typeNextValue = typeof nextValue;\r\n\r\n        let prevValue = key in handlers ? handlers[key] : currentProps[key],\r\n            typePrevValue = typeof prevValue;\r\n\r\n        if (nextValue === prevValue) continue;\r\n\r\n        if (key === \"key\") {\r\n            if (node.dataset.key !== nextValue) node.dataset.key = nextValue;\r\n            continue;\r\n        }\r\n        // updates the state of the ref object\r\n        if (key === \"ref\") {\r\n            if (nextValue) nextValue.current = node;\r\n            continue;\r\n        }\r\n\r\n        // Enables the use of shadowDom over the node\r\n        if (SHADOWDOM === key && \"attachShadow\" in node) {\r\n            if (\r\n                (node.shadowRoot && !nextValue) ||\r\n                (!node.shadowRoot && nextValue)\r\n            ) {\r\n                node.attachShadow({ mode: nextValue ? \"open\" : \"closed\" });\r\n            }\r\n            continue;\r\n        }\r\n\r\n        if (typeNextValue === \"function\" || typePrevValue === \"function\") {\r\n            updateEvent(node, key, prevValue, nextValue, handlers);\r\n            isHandler = true;\r\n        } else if ((key in node && !isSvg) || (isSvg && key === \"style\")) {\r\n            if (key === \"style\") {\r\n                nextValue = updateStyle(\r\n                    node,\r\n                    prevValue || node.style.cssText,\r\n                    nextValue\r\n                );\r\n            } else {\r\n                node[key] = nextValue;\r\n            }\r\n        } else {\r\n            isSvg\r\n                ? node.setAttributeNS(\r\n                      isSvg && key === \"xlink\"\r\n                          ? \"http://www.w3.org/1999/xlink\"\r\n                          : null,\r\n                      key === \"xlink\" ? \"xlink:href\" : key,\r\n                      nextValue\r\n                  )\r\n                : node.setAttribute(key, nextValue);\r\n        }\r\n        if (!isHandler) {\r\n            currentProps[key] = nextValue;\r\n        }\r\n    }\r\n    node[ATTRS_VALUE] = currentProps;\r\n}\r\n","import { options } from \"./options\";\r\nlet task = [],\r\n    defer = Promise.resolve();\r\n/**\r\n * allows to solve the pending tasks\r\n */\r\nfunction resolve() {\r\n    let currentTask = task,\r\n        length = currentTask.length;\r\n\r\n    task = [];\r\n\r\n    for (let i = 0; i < length; i++) {\r\n        let item = currentTask[i];\r\n        // discounts a level to the pending task, if it reaches 0 it is executed\r\n        if (--item.lvl) {\r\n            item.fun(item.arg);\r\n        } else {\r\n            // if the number of queued tasks is greater than\r\n            // options.maxConcurrentTask, the subsequent queue will be left\r\n            if (task.length > options.maxConcurrentTask) item.lvl++;\r\n            // Rescue the task to add it to the next queue\r\n            task.push(item);\r\n        }\r\n    }\r\n    // If there are remaining tasks, generate another cycle to clean the tasks\r\n    if (task.length) defer.then(resolve); //;setTimeout(() => defer.then(resolve));\r\n}\r\n/**\r\n * add a task to the waiting list\r\n * @param {function} fun - function to execute once the task has been solved.\r\n * @param {*} [arg] - argument to deliver to the task, once it is resolved\r\n * @param {number} [lvl] - level of importance 1 is important 2 is less important and so on\r\n */\r\nexport function setTask(fun, arg, lvl = 1) {\r\n    let length = task.length;\r\n    //if (length > options.maxConcurrentTask) lvl++;\r\n    task.push({ fun, arg, lvl });\r\n    // a cycle is created only if there is not one running\r\n    if (!length) {\r\n        defer.then(resolve);\r\n    }\r\n}\r\n","import { setTask } from \"./task\";\r\nimport {\r\n    COMPONENT_CREATE,\r\n    COMPONENT_UPDATE,\r\n    COMPONENT_CREATED,\r\n    COMPONENT_UPDATED,\r\n    COMPONENT_REMOVE\r\n} from \"./constants\";\r\n\r\nimport { update as updateNode } from \"./update\";\r\n\r\nlet CURRENT_SNAP, CURRENT_SNAP_KEY_HOOK;\r\n\r\nexport function getCurrentSnap() {\r\n    if (!CURRENT_SNAP) {\r\n        throw new Error(\r\n            \"the hooks can only be called from an existing functional component in the diff queue\"\r\n        );\r\n    }\r\n    return CURRENT_SNAP;\r\n}\r\n\r\nexport function useHook(reducer) {\r\n    let component = getCurrentSnap().component,\r\n        index = CURRENT_SNAP_KEY_HOOK++,\r\n        hook,\r\n        isCreate;\r\n    if (!component.hooks[index]) {\r\n        isCreate = true;\r\n        component.hooks[index] = {};\r\n    }\r\n    hook = component.hooks[index];\r\n    hook.reducer = reducer;\r\n    if (isCreate) dispatchHook(hook, { type: COMPONENT_CREATE });\r\n    return [hook.state, action => dispatchHook(hook, action)];\r\n}\r\n\r\nexport function dispatchHook(hook, action) {\r\n    hook.state = hook.reducer(hook.state, action);\r\n}\r\n\r\nexport function dispatchComponents(components, action) {\r\n    let length = components.length;\r\n    for (let i = 0; i < length; i++) {\r\n        let component = components[i],\r\n            hooks = component.hooks,\r\n            hooksLength = hooks.length;\r\n        if (action.type === COMPONENT_REMOVE) {\r\n            component.remove = true;\r\n        }\r\n        for (let i = 0; i < hooksLength; i++) {\r\n            dispatchHook(hooks[i], action);\r\n        }\r\n    }\r\n}\r\n/**\r\n * this function allows creating a block that analyzes the tag\r\n * defined as a function, in turn creates a global update scope for hook management.\r\n */\r\nexport function createUpdateComponent(ID, isSvg) {\r\n    let prevent,\r\n        store = [],\r\n        host;\r\n    /**\r\n     * This function allows reducing the functional components based on\r\n     * their return, in turn creates a unique state for each component\r\n     * according to a depth index\r\n     * @param {function} vnode\r\n     * @param {object} context\r\n     * @param {number} deep\r\n     */\r\n    function reduce(vnode, context, deep) {\r\n        // if host does not exist as a node, the vnode is not reduced\r\n        if (!host) return;\r\n        vnode = vnode || \"\";\r\n        // if it is different from a functional node, it is sent to updateNode again\r\n        if (typeof vnode.tag !== \"function\") {\r\n            dispatchComponents(store.splice(deep), {\r\n                type: COMPONENT_REMOVE\r\n            });\r\n            host = updateNode(ID, host, vnode, isSvg, context, updateComponent);\r\n            // if the store no longer has a length, it is assumed that the updateComponent is no longer necessary\r\n            if (store.length) host[ID].updateComponent = updateComponent;\r\n\r\n            return;\r\n        }\r\n        // you get the current component\r\n        let component = store[deep] || {},\r\n            isCreate,\r\n            useNext;\r\n        // if the current component is dis- torted to the analyzed one,\r\n        // the previous state is replaced with a new one and the elimination is dispatched.\r\n        if (component.tag !== vnode.tag) {\r\n            isCreate = true;\r\n            // the state of the component is defined\r\n            store[deep] = {\r\n                lvl: 1,\r\n                size: 1,\r\n                tag: vnode.tag,\r\n                hooks: [],\r\n                props: {},\r\n                context: {}\r\n            };\r\n            // the elimination is sent to the successors of the previous component\r\n            dispatchComponents(store.splice(deep + 1), {\r\n                type: COMPONENT_REMOVE\r\n            });\r\n            useNext = true;\r\n        }\r\n\r\n        component = store[deep];\r\n        // then a series of simple processes are carried out capable of\r\n        // identifying if the component requires an update\r\n        if (component.context !== vnode.useContext) {\r\n            // the current context is stored in the cache\r\n            component.context = vnode.useContext;\r\n            // create a new context\r\n            context = { ...context, ...vnode.useContext };\r\n            useNext = true;\r\n        }\r\n\r\n        if (!useNext) {\r\n            // compare the lake of properties\r\n            if (vnode.size !== component.size) useNext = true;\r\n            if (!useNext) {\r\n                // buy property by property, so the properties to be used\r\n                // in the areas must be immutable\r\n                for (let key in vnode.props) {\r\n                    if (vnode.props[key] !== component.props[key]) {\r\n                        useNext = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        component.props = vnode.props;\r\n        component.size = vnode.size;\r\n        /**\r\n         * this function is a snapshot of the current component,\r\n         * allows to run the component and launch the next update\r\n         */\r\n        function next() {\r\n            if (component.remove) return host;\r\n\r\n            CURRENT_SNAP = {\r\n                component,\r\n                context,\r\n                // allows access to the instantaneous, but it uses the microtareas\r\n                // to prevent multiple synchronous updates\r\n                next() {\r\n                    if (!component.prevent) {\r\n                        component.prevent = true;\r\n                        setTask(() => {\r\n                            component.prevent = false;\r\n                            next();\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n\r\n            CURRENT_SNAP_KEY_HOOK = 0;\r\n\r\n            dispatchComponents([component], { type: COMPONENT_UPDATE });\r\n\r\n            let vnextnode = component.tag(component.props, context);\r\n\r\n            CURRENT_SNAP = false;\r\n            CURRENT_SNAP_KEY_HOOK = 0;\r\n\r\n            reduce(vnextnode, context, deep + 1);\r\n\r\n            dispatchComponents([component], {\r\n                type: isCreate ? COMPONENT_CREATED : COMPONENT_UPDATED\r\n            });\r\n\r\n            isCreate = false;\r\n        }\r\n\r\n        if (useNext && !component.prevent) next();\r\n    }\r\n    /**\r\n     *\r\n     * @param {string} type\r\n     * @param {HTMLElement|SVGElement|Text} nextHost\r\n     * @param {object} vnode\r\n     * @param {object} context\r\n     */\r\n    function updateComponent(type, nextHost, vnode, context) {\r\n        switch (type) {\r\n            case COMPONENT_UPDATE:\r\n                host = nextHost;\r\n                reduce(vnode, context, 0);\r\n                return host;\r\n            case COMPONENT_REMOVE:\r\n                host = false;\r\n                dispatchComponents(history, { type });\r\n                history = [];\r\n                break;\r\n        }\r\n    }\r\n\r\n    return updateComponent;\r\n}\r\n","import { NODE_TEXT, NODE_HOST, TAG_VALUE, COMPONENT_UPDATE } from \"./constants\";\r\nimport { options } from \"./options\";\r\nimport { defineVnode } from \"./vnode\";\r\nimport { updateChildren } from \"./updateChildren\";\r\nimport { updateProperties } from \"./updateProperties\";\r\nimport { createUpdateComponent } from \"./component\";\r\nimport { setTask } from \"./task\";\r\nimport { createVnode } from \"./vnode\";\r\n/**\r\n * @param {object} vnode\r\n * @param {HTMLElement|SVGElement} node\r\n * @param {string} [customID]\r\n * @param {boolean} disableHost\r\n */\r\nexport function render(vnode, node, disableHost, customID = \"vstate\") {\r\n    if (!disableHost) {\r\n        vnode = defineVnode(vnode);\r\n        if (vnode.tag !== NODE_HOST) {\r\n            vnode = createVnode(NODE_HOST, {}, [vnode]);\r\n        }\r\n    }\r\n    update(customID, node, vnode);\r\n}\r\n\r\nexport function createNode(tag, isSvg) {\r\n    let doc = options.document || document,\r\n        nextNode;\r\n    if (tag !== NODE_TEXT) {\r\n        nextNode = isSvg\r\n            ? doc.createElementNS(\"http://www.w3.org/2000/svg\", tag)\r\n            : doc.createElement(tag);\r\n    } else {\r\n        nextNode = doc.createTextNode(\"\");\r\n    }\r\n    nextNode[TAG_VALUE] = tag;\r\n    return nextNode;\r\n}\r\n\r\nexport function getNodeName(node) {\r\n    if (!node) return;\r\n    // store the process locally in the node to avoid transformation\r\n    if (!node[TAG_VALUE]) {\r\n        node[TAG_VALUE] = node.nodeName.toLowerCase();\r\n    }\r\n    return node[TAG_VALUE];\r\n}\r\n/**\r\n *\r\n * @param {string} ID - store the process locally in the node to avoid transformation\r\n * @param {HTMLElement|SVGElement|Text|undefined} prevNode - if the current node is defined and the next\r\n * one to be used is different, the replacement of the current node will be made\r\n * @param {*} vnode\r\n * @param {boolean} isSvg\r\n * @param {object} context\r\n * @param {function|undefined} currentUpdateComponent\r\n */\r\nexport function update(\r\n    ID,\r\n    prevNode,\r\n    vnode,\r\n    isSvg,\r\n    context,\r\n    currentUpdateComponent\r\n) {\r\n    // get a node object\r\n    vnode = defineVnode(vnode);\r\n    // if the previous state exists, it obtains the state\r\n    let { vnode: vprevnode, handlers = {}, updateComponent } =\r\n        (prevNode && prevNode[ID]) || {};\r\n    // if the node stored in the previous state is identical to the current one,\r\n    // it will not execute the update process\r\n    if (vnode === vprevnode) return prevNode;\r\n\r\n    let {\r\n        // defines the next node to manipulate the concurrent tree\r\n        tag: nextTag,\r\n        // define the properties that the next node must possess\r\n        props: nextProps,\r\n        // define the children that this node must possess in the following state\r\n        children: nextChildren,\r\n        // transmits keys to the updateChildren that is kept in the children list\r\n        useKeys,\r\n        // define if they would use updateChildren\r\n        useChildren,\r\n        // define if shadowDom was used\r\n        useShadowDom\r\n    } = vnode;\r\n    // define if the tree is of the SVG type\r\n    isSvg = isSvg || nextTag === \"svg\";\r\n\r\n    let nextNode = prevNode,\r\n        isFunction = typeof nextTag === \"function\";\r\n\r\n    // create an updateComponent\r\n    if (isFunction && !updateComponent) {\r\n        updateComponent = createUpdateComponent(ID, isSvg);\r\n    }\r\n\r\n    if (\r\n        getNodeName(prevNode) !== nextTag &&\r\n        nextTag !== \"host\" &&\r\n        !isFunction\r\n    ) {\r\n        nextNode = createNode(nextTag, isSvg);\r\n        handlers = {};\r\n        let parent = prevNode && prevNode.parentNode;\r\n        if (parent) parent.replaceChild(nextNode, prevNode);\r\n    }\r\n    if (updateComponent && currentUpdateComponent !== updateComponent) {\r\n        return updateComponent(COMPONENT_UPDATE, nextNode, vnode, context);\r\n    } else if (nextTag !== NODE_TEXT) {\r\n        updateProperties(nextNode, nextProps, handlers, isSvg);\r\n        if (useChildren && (vprevnode || {}).children !== vnode.children) {\r\n            updateChildren(\r\n                ID,\r\n                useShadowDom ? nextNode.shadowRoot || nextNode : nextNode,\r\n                nextChildren,\r\n                useKeys,\r\n                isSvg,\r\n                context\r\n            );\r\n        }\r\n    } else {\r\n        if (nextNode.nodeValue !== nextChildren) {\r\n            nextNode.nodeValue = nextChildren;\r\n        }\r\n    }\r\n\r\n    nextNode[ID] = { handlers, vnode, updateComponent };\r\n\r\n    return nextNode;\r\n}\r\n","import { getCurrentSnap, useHook } from \"./component\";\r\n\r\nimport { isEqualArray } from \"./utils\";\r\n\r\nimport {\r\n    COMPONENT_CREATE,\r\n    COMPONENT_CREATED,\r\n    COMPONENT_UPDATE,\r\n    COMPONENT_UPDATED,\r\n    COMPONENT_REMOVE,\r\n    COMPONENT_CLEAR\r\n} from \"./constants\";\r\n\r\nexport function useState(initialState) {\r\n    let next = getCurrentSnap().next,\r\n        type = \"useState/update\";\r\n    let [state, dispatch] = useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n                return typeof initialState === \"function\"\r\n                    ? initialState()\r\n                    : initialState;\r\n            case type:\r\n                let nextState = action.state;\r\n                return typeof nextState === \"function\"\r\n                    ? nextState(state)\r\n                    : nextState;\r\n        }\r\n        return state;\r\n    });\r\n    return [\r\n        state,\r\n        state => {\r\n            dispatch({ state, type });\r\n            next();\r\n        }\r\n    ];\r\n}\r\n\r\nexport function useEffect(callback, args) {\r\n    useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n                return { args };\r\n            case COMPONENT_UPDATE:\r\n            case COMPONENT_REMOVE:\r\n                if (state.clear) {\r\n                    let next =\r\n                        action.type === COMPONENT_REMOVE ||\r\n                        (args && state.args\r\n                            ? !isEqualArray(args, state.args)\r\n                            : true);\r\n                    if (next) state.clear();\r\n                }\r\n                return { ...state, args };\r\n            case COMPONENT_CREATED:\r\n            case COMPONENT_UPDATED:\r\n                let next =\r\n                        action.type === COMPONENT_CREATED ||\r\n                        (args && state.args\r\n                            ? !isEqualArray(args, state.args)\r\n                            : true),\r\n                    clear = state.clear;\r\n                if (next) {\r\n                    clear = callback();\r\n                }\r\n                return { ...state, clear, args };\r\n        }\r\n        return state;\r\n    });\r\n}\r\n\r\nexport function useRef(current) {\r\n    let [state] = useHook((state = {}, action) =>\r\n        action.type === COMPONENT_CREATE ? { current } : state\r\n    );\r\n    return state;\r\n}\r\n\r\nexport function useMemo(callback, args) {\r\n    let [state] = useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n            case COMPONENT_UPDATE:\r\n                return {\r\n                    args,\r\n                    value:\r\n                        action.type === COMPONENT_CREATE\r\n                            ? callback()\r\n                            : isEqualArray(args, state.args)\r\n                            ? state.value\r\n                            : callback()\r\n                };\r\n        }\r\n        return state;\r\n    });\r\n    return state.value;\r\n}\r\n\r\nexport function useReducer(reducer, initialState) {\r\n    let next = getCurrentSnap().next,\r\n        type = \"useReducer/update\";\r\n    let [state, dispatch] = useHook((state, action) => {\r\n        switch (action.type) {\r\n            case COMPONENT_CREATE:\r\n                return initialState;\r\n            case type:\r\n                return reducer(state, action.use);\r\n        }\r\n        return state;\r\n    });\r\n    return [\r\n        state,\r\n        use => {\r\n            dispatch({ type, use });\r\n            next();\r\n        }\r\n    ];\r\n}\r\n","import { h, useEffect, useState } from \"../../../src/index\";\r\n\r\nexport default function Dot({ s, y, x, size }) {\r\n    s = size * 1.3;\r\n    let [count, setCount] = useState(0);\r\n    let [hover, setHover] = useState();\r\n\r\n    useEffect(() => {\r\n        setInterval(() => {\r\n            count = count > 9 ? 0 : count;\r\n            setCount(++count);\r\n        }, 1000);\r\n    }, []);\r\n\r\n    return (\r\n        <div\r\n            style={`\r\n                position: absolute;\r\n                font: normal 15px sans-serif;\r\n                text-align: center;\r\n                cursor: pointer;\r\n                width: ${s}px;\r\n                height: ${s}px;\r\n                left: ${x}px;\r\n                top: ${y}px;\r\n                border-radius: ${s / 2}px;\r\n                line-height: ${s}px;\r\n                background: ${hover ? \"#ff0\" : \"#61dafb\"}\r\n            `}\r\n            onmouseenter={() => setHover(true)}\r\n            onmouseleave={() => setHover(false)}\r\n        >\r\n            {count}\r\n        </div>\r\n    );\r\n}\r\n","import { h, useMemo } from \"../../../src/index\";\r\n\r\nimport Dot from \"./dot\";\r\nlet targetSize = 25;\r\n\r\nexport default function Triangle({ s, y, x }) {\r\n    if (s <= targetSize) {\r\n        return (\r\n            <Dot\r\n                x={x - targetSize / 2}\r\n                y={y - targetSize / 2}\r\n                size={targetSize}\r\n            />\r\n        );\r\n    }\r\n\r\n    s = s / 2;\r\n    return (\r\n        <div>\r\n            <Triangle x={x} y={y - s / 2} s={s} />\r\n            <Triangle x={x - s} y={y + s / 2} s={s} />\r\n            <Triangle x={x + s} y={y + s / 2} s={s} />\r\n        </div>\r\n    );\r\n}\r\n","import { h, render, useState, useEffect } from \"../../../src/index\";\r\nimport Triange from \"./triangle\";\r\n\r\nfunction Run(props) {\r\n    let [time, setTime] = useState(0);\r\n    let t = (time / 1000) % 10;\r\n    let scale = 1 + (t > 5 ? 10 - t : t) / 10;\r\n\r\n    useEffect(() => {\r\n        let start = Date.now();\r\n        function update() {\r\n            setTime(Date.now() - start);\r\n            requestAnimationFrame(update);\r\n        }\r\n        let currentAnimation = requestAnimationFrame(update);\r\n        () => {\r\n            cancelAnimationFrame(currentAnimation);\r\n        };\r\n    }, []);\r\n\r\n    return (\r\n        <div\r\n            shadowDom\r\n            style={`\r\n                position:absolute;\r\n                transform-origin : 0 0;\r\n                left:50%;\r\n                top:50%;\r\n                width:10px;\r\n                height:10px;\r\n                background:#eee;\r\n                transform: scaleX( ${scale /\r\n                    2.1}) scaleY(0.7) translateZ(0.1px);\r\n            `}\r\n        >\r\n            <Triange x={0} y={0} s={1000} />\r\n        </div>\r\n    );\r\n}\r\n\r\nrender(<Run />, document.querySelector(\"#app\"));\r\n"],"names":["const","NODE_TEXT","NODE_HOST","TAG_VALUE","ATTRS_VALUE","SHADOWDOM","COMPONENT_CREATE","COMPONENT_UPDATE","COMPONENT_CREATED","COMPONENT_UPDATED","COMPONENT_REMOVE","EMPTY_CHILDREN","EVENT_ALIAS","options","maxConcurrentTask","isArray","value","Array","isEqualArray","before","after","let","length","i","h","tag","props","createVnode","children","defineVnode","type","nextProps","nextChildren","useKeys","key","useContext","useShadowDom","size","useChildren","mapChildren","deep","recicleChildren","child","undefined","Error","push","index","clearNode","ID","node","nodeList","childNodes","dispatch","CSS_PROPS","updateStyle","prevValue","nextValue","prevCss","nextCss","replace","all","letterBefore","letterAfter","toLowerCase","style","cssText","updateEvent","prevHandler","nextHandler","handlers","slice","toLocaleLowerCase","event","call","target","eventProxy","removeEventListener","addEventListener","IGNORE","CURRENT_SNAP","CURRENT_SNAP_KEY_HOOK","task","defer","Promise","resolve","currentTask","item","lvl","fun","arg","then","getCurrentSnap","useHook","reducer","hook","isCreate","component","hooks","dispatchHook","state","action","dispatchComponents","components","hooksLength","remove","createUpdateComponent","isSvg","host","store","reduce","vnode","context","splice","updateNode","updateComponent","useNext","Object","prevent","next","setTask","vnextnode","nextHost","history","createNode","nextNode","doc","document","createElementNS","createElement","createTextNode","update","prevNode","currentUpdateComponent","vprevnode","nextTag","isFunction","nodeName","getNodeName","parent","parentNode","replaceChild","currentProps","dataset","removeAttribute","isHandler","typeNextValue","typePrevValue","shadowRoot","attachShadow","mode","setAttributeNS","setAttribute","current","updateProperties","vnextChildren","nodeKeys","nodeListLength","vnodeListLength","nodeListIndexStart","nodeChild","isRemove","removeChild","nextSibling","indexChild","prevChild","insertBefore","appendChild","updateChildren","nodeValue","useState","initialState","nextState","useEffect","callback","args","clear","Dot","ref","s","setInterval","count","setCount","x","y","hover","onmouseenter","setHover","onmouseleave","disableHost","customID","targetSize","Triangle","t","time","scale","start","Date","now","requestAnimationFrame","setTime","shadowDom","Triange","querySelector"],"mappings":"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"}